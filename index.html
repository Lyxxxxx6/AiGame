<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>CYBER RUSH: DEBUG EDITION</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        body { margin: 0; overflow: hidden; background: #050510; color: #fff; font-family: 'Orbitron', sans-serif; user-select: none; }
        #game-container { position: relative; width: 100vw; height: 100vh; overflow: hidden;}
        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }
        /* UI 层 */
        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #hud-top { display: flex; justify-content: space-between; padding: 30px; font-weight: 900; letter-spacing: 2px; text-shadow: 0 0 10px #0ff; }
        .stat-value { font-size: 40px; color: #fff; text-shadow: 2px 2px 0 #f0f; }
        #speed-container { position: absolute; top: 10%; left: 50%; transform: translateX(-50%) skew(-10deg); text-align: center; }
        #speed-val { font-size: 100px; line-height: 80px; font-weight: 900; background: linear-gradient(to bottom, #fff, #888); -webkit-background-clip: text; -webkit-text-fill-color: transparent; filter: drop-shadow(0 0 15px #0ff); }
        #speed-unit { font-size: 24px; color: #0ff; letter-spacing: 5px; }
        #rage-container { position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%); width: 600px; height: 40px; border: 4px solid #fff; transform: skew(-20deg); box-shadow: 0 0 30px #f00; background: rgba(0,0,0,0.5); }
        #rage-fill { width: 0%; height: 100%; background: repeating-linear-gradient(45deg, #f00, #f00 10px, #900 10px, #900 20px); transition: width 0.05s linear; }
        #center-msg { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); text-align: center; white-space: nowrap; z-index: 10; display: none; text-shadow: 0 0 20px #f00;}
        .msg-big { font-size: 120px; font-weight: 900; color: #fff; -webkit-text-stroke: 4px #000; }
        .msg-sub { font-size: 40px; color: #0ff; background: #000; padding: 5px 20px; }

        /* Debug 提示 */
        #debug-info { position: absolute; bottom: 10px; left: 10px; color: #0f0; font-family: monospace; font-size: 12px; z-index: 100; pointer-events: none; }

        /* 菜单样式 */
        #menu-layer { background: rgba(0,0,0,0.85); backdrop-filter: blur(10px); display: flex; flex-direction: column; justify-content: center; align-items: center; pointer-events: auto; }
        .glitch-title { font-size: 80px; font-weight: 900; color: #fff; text-shadow: 4px 0 #f00, -4px 0 #0ff; margin-bottom: 20px; }
        .menu-view { display: flex; flex-direction: column; align-items: center; width: 100%; transition: opacity 0.3s; }
        .settings-box { background: rgba(0,20,40,0.9); border: 1px solid #0ff; padding: 30px; margin-bottom: 20px; width: 600px; text-align: left; box-shadow: 0 0 30px rgba(0,255,255,0.1); border-radius: 4px; }
        .setting-item { margin-bottom: 25px; }
        .setting-label { color: #fff; font-size: 18px; display:flex; justify-content:space-between; margin-bottom: 8px; font-weight: 700;}
        input[type=range] { width: 100%; height: 6px; background: #333; outline: none; -webkit-appearance: none; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; background: #0ff; cursor: pointer; border: 2px solid #fff; box-shadow: 0 0 10px #0ff; }
        button { background: #000; border: 2px solid #0ff; color: #0ff; padding: 15px 40px; margin: 10px; font-size: 24px; font-family: 'Orbitron'; cursor: pointer; text-transform: uppercase; transition: 0.2s; position: relative; overflow: hidden; width: 400px; }
        button:hover { background: #0ff; color: #000; box-shadow: 0 0 30px #0ff; }
    </style>
</head>
<body>
<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div id="debug-info">DEBUG MODE: HITBOX ENABLED</div>
    <div id="hud" class="ui-layer" style="display: none;">
        <div id="hud-top">
            <div class="stat-group"><div class="stat-label">SCORE</div><div id="score-val" class="stat-value">0</div></div>
            <div class="stat-group" style="align-items: flex-end;"><div class="stat-label">KILLS</div><div id="kill-val" class="stat-value" style="color:#f33">0</div></div>
        </div>
        <div id="speed-container">
            <div id="speed-val">0</div>
            <div id="speed-unit">KM/H</div>
        </div>
        <div id="center-msg"></div>
        <div id="rage-container"><div id="rage-fill"></div></div>
    </div>
    <div id="menu-layer" class="ui-layer">
        <div class="glitch-title">CYBER RUSH</div>
        <div id="view-main" class="menu-view">
            <button onclick="startGame()">启动引擎</button>
            <button onclick="switchView('settings')">系统设置</button>
        </div>
        <div id="view-settings" class="menu-view" style="display: none;">
            <div class="settings-box">
                <h3 style="color: #0ff; border-bottom: 1px solid #444; padding-bottom: 10px; margin-top: 0;">赛道生成参数</h3>
                <div class="setting-item">
                    <label class="setting-label">建筑密度 <span id="val-den" style="color:#0f0">中等</span></label>
                    <input type="range" id="set-den" min="0" max="10" value="5">
                </div>
                <div class="setting-item">
                    <label class="setting-label">赛道宽度 <span id="val-road" style="color:#0f0">100%</span></label>
                    <input type="range" id="set-road" min="50" max="150" value="100">
                </div>
                <h3 style="color: #f0f; border-bottom: 1px solid #444; padding-bottom: 10px; margin-top: 30px;">游戏参数</h3>
                <div class="setting-item">
                    <label class="setting-label">车流密度 <span id="val-traf" style="color:#f0f">2%</span></label>
                    <input type="range" id="set-traf" min="0" max="10" value="2">
                </div>
                <div class="setting-item">
                    <label class="setting-label">车流速度 <span id="val-spd" style="color:#ff0">正常</span></label>
                    <input type="range" id="set-spd" min="1" max="5" value="2">
                </div>
            </div>
            <button onclick="applySettings()">应用并重启</button>
            <button onclick="switchView('main')" style="border-color:#666; color:#888;">返回</button>
        </div>
    </div>
</div>

<script>
    // --- 定义车辆和障碍物样式库 ---
    const CAR_STYLES = {
        'sedan': { w: 400, h: 220, color: '#333', lights: 'h-bar', speedVar: 1.0 },
        'truck': { w: 500, h: 450, color: '#112', lights: 'v-side', speedVar: 0.8 },
        'racer': { w: 420, h: 180, color: '#222', lights: 'quad', speedVar: 1.4 },
        'tank':  { w: 480, h: 300, color: '#232', lights: 'center', speedVar: 0.9 }
    };
    const OBS_STYLES = {
        'crate':   { w: 300, h: 300, color: '#d60', type: 'box' },
        'barrier': { w: 400, h: 180, color: '#ccc', type: 'trap' },
        'glitch':  { w: 250, h: 400, color: '#f0f', type: 'crystal' }
    };

    // --- 基础常量 ---
    const CONFIG = {
        segL: 200,
        laneW: 2400,
        roadW: 2200,
        camH: 5500,         // 相机高度
        camD: 0.95,
        drawDist: 500,
        accel: 100,
        maxSpeed: 14000,
        rushSpeed: 120000,
        rageDrain: 5,
        ragePerHit: 8,
        centrifugal: 0.35,
        colors: {
            sky: '#050510',
            roadDark: '#101015', roadLight: '#181820',
            grassDark: '#020205', grassLight: '#040408'
        }
    };
    const SETTINGS = {
        roadWidthScale: 1.0,
        buildDensity: 0.5,
        carDensity: 0.02,
        carSpeedMult: 1.0
    };
    const STATE = { MENU: 0, PLAY: 1, RUSH: 2 };
    const PALETTES = [
        { base: '#1a0033', light: '#d0f' },
        { base: '#001a33', light: '#0ff' },
        { base: '#331a00', light: '#fa0' },
        { base: '#00331a', light: '#0f6' },
        { base: '#222',    light: '#fff' }
    ];
    let game = {
        state: STATE.MENU,
        time: 0, dt: 0,
        segments: [], cars: [], particles: [],
        player: { x: 0, z: 0, speed: 0, score: 0, rage: 0, kills: 0 },
        keys: { left: false, right: false },
        cam: { shake: 0 },
        audio: null
    };
    let speedTier = 0;
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    let W, H;

    function init() {
        resize();
        window.addEventListener('resize', resize);
        window.addEventListener('keydown', e => {
            if(e.key === 'ArrowLeft' || e.key === 'a') game.keys.left = true;
            if(e.key === 'ArrowRight' || e.key === 'd') game.keys.right = true;
        });
        window.addEventListener('keyup', e => {
            if(e.key === 'ArrowLeft' || e.key === 'a') game.keys.left = false;
            if(e.key === 'ArrowRight' || e.key === 'd') game.keys.right = false;
        });
        bindUI();
    }

    function bindUI() {
        const denInput = document.getElementById('set-den');
        denInput.oninput = function() {
            SETTINGS.buildDensity = this.value / 10;
            let txt = "稀疏"; if(this.value>3) txt="中等"; if(this.value>7) txt="密集";
            document.getElementById('val-den').innerText = txt;
        };
        const roadInput = document.getElementById('set-road');
        roadInput.oninput = function() {
            SETTINGS.roadWidthScale = this.value / 100;
            document.getElementById('val-road').innerText = this.value + "%";
        };
        const trafInput = document.getElementById('set-traf');
        trafInput.oninput = function() {
            SETTINGS.carDensity = this.value / 100;
            document.getElementById('val-traf').innerText = this.value + "%";
        };
        const spdInput = document.getElementById('set-spd');
        spdInput.oninput = function() {
            const val = parseInt(this.value);
            SETTINGS.carSpeedMult = [0.5, 1.0, 1.5, 2.0, 3.0][val - 1];
            document.getElementById('val-spd').innerText = ["缓慢", "正常", "快速", "狂暴", "封顶"][val - 1];
        };
    }
    function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
    function switchView(name) {
        document.getElementById('view-main').style.display = name === 'main' ? 'flex' : 'none';
        document.getElementById('view-settings').style.display = name === 'settings' ? 'flex' : 'none';
    }
    function applySettings() { startGame(); }
    function startGame() {
        if (!game.audio) initAudio();
        game.segments = [];
        game.cars = [];
        game.particles = [];
        game.player = { x: 0, z: 0, speed: 0, score: 0, rage: 0, kills: 0 };
        game.state = STATE.PLAY;
        generateTrack();
        document.getElementById('menu-layer').style.display = 'none';
        document.getElementById('hud').style.display = 'block';
        document.getElementById('game-container').classList.remove('rush-active');
        showMsg("引擎点火", "RACE START", 2000);
        gameLoop(0);
    }

    // --- 赛道生成 ---
    function generateTrack() {
        const totalSegs = 4000;
        const roadEdgeNorm = (CONFIG.roadW / CONFIG.laneW);
        let buildAccumulator = 0;
        let currentHeight = 0;
        let sectionType = 'straight';
        let sectionLeft = 0;
        let targetCurve = 0;
        let targetHeight = 0;
        let startHeight = 0;

        for (let i = 0; i < totalSegs; i++) {
            if (sectionLeft <= 0) {
                const r = Math.random();
                if (r < 0.3) {
                    sectionType = 'straight'; sectionLeft = 50 + Math.random() * 50;
                    targetCurve = 0; targetHeight = currentHeight;
                } else if (r < 0.7) {
                    sectionType = 'curve'; sectionLeft = 80 + Math.random() * 100;
                    targetCurve = (Math.random() > 0.5 ? 1 : -1) * (2 + Math.random() * 4);
                    targetHeight = currentHeight;
                } else {
                    sectionType = 'hill'; sectionLeft = 60 + Math.random() * 60;
                    targetCurve = 0; startHeight = currentHeight;
                    let dir = (Math.random() > 0.5 ? 1 : -1);
                    if (currentHeight > 3000) dir = -1;
                    if (currentHeight < -1000) dir = 1;
                    targetHeight = currentHeight + dir * (2000 + Math.random() * 3000);
                }
            }

            let actualCurve = 0;
            if (sectionType === 'curve') {
                actualCurve = targetCurve;
                if (sectionLeft < 20) actualCurve = targetCurve * (sectionLeft/20);
            }
            if (sectionType === 'hill') {
                if (Math.abs(targetHeight - currentHeight) > 10) {
                    currentHeight += (targetHeight - startHeight) / 60;
                }
            }
            sectionLeft--;

            const buildings = [];
            buildAccumulator += SETTINGS.buildDensity;
            if (buildAccumulator > 1.0 + Math.random()) {
                buildAccumulator = 0;
                const isLandmark = Math.random() < 0.05;
                buildings.push(createBuilding(-1, roadEdgeNorm, isLandmark, i/totalSegs));
                buildings.push(createBuilding(1, roadEdgeNorm, isLandmark, i/totalSegs));
            }

            const sprites = [];
            if (i > 50 && Math.random() < 0.03) {
                const safeZone = roadEdgeNorm * 0.8;
                const keys = Object.keys(OBS_STYLES);
                const styleKey = keys[Math.floor(Math.random() * keys.length)];
                sprites.push({
                    type: 'obs',
                    style: styleKey,
                    x: (Math.random()*2 - 1) * safeZone,
                    size: 0.8 + Math.random() * 0.4
                });
            }

            if (i > 50 && Math.random() < SETTINGS.carDensity) {
                const safeZone = roadEdgeNorm * 0.8;
                const keys = Object.keys(CAR_STYLES);
                const styleKey = keys[Math.floor(Math.random() * keys.length)];
                const styleData = CAR_STYLES[styleKey];
                let speed = (3000 + Math.random()*2000) * SETTINGS.carSpeedMult * styleData.speedVar;
                game.cars.push({
                    z: i * CONFIG.segL,
                    x: (Math.random()*2-1)*safeZone,
                    speed: speed,
                    active: true,
                    style: styleKey,
                    colorVar: Math.random()
                });
            }

            game.segments.push({
                index: i,
                p1: { world: { y: currentHeight, z: i*CONFIG.segL }, camera: {}, screen: {} },
                p2: { world: { y: currentHeight, z: (i+1)*CONFIG.segL }, camera: {}, screen: {} },
                curve: actualCurve,
                sprites: sprites,
                buildings: buildings,
                color: Math.floor(i/5)%2 ? CONFIG.colors.roadDark : CONFIG.colors.roadLight
            });
        }
        for(let i=0; i<totalSegs-1; i++) {
            game.segments[i].p2.world.y = game.segments[i+1].p1.world.y;
        }
    }

    function randRange(a,b){ return a + Math.random()*(b-a); }
    function createBuilding(side, roadEdgeNorm, isLandmark, progress){
        const width = isLandmark ? randRange(4.2,5.5) : randRange(1.2,3.5);
        const heightBase = isLandmark ? randRange(12000,20000) : randRange(4000,12000);
        const speedBoost = 1 + progress * 0.6;
        const height = heightBase * speedBoost;
        const buffer = 0.2 + Math.random()*0.25;
        const x = side * (roadEdgeNorm + buffer + width/2);
        const type = isLandmark ? ['mega','tower','gate'][Math.floor(Math.random()*3)] : 'normal';
        return { x, w: width, h: height, c: Math.random(), type, seed: Math.random() };
    }

    let lastTime = 0;
    function gameLoop(time) {
        if (game.state === STATE.MENU) return;
        const dt = Math.min(0.1, (time - lastTime) / 1000);
        lastTime = time;
        update(dt);
        render();
        requestAnimationFrame(gameLoop);
    }

    // --- 核心更新逻辑 ---
    function update(dt) {
        const p = game.player;
        const maxS = (game.state === STATE.RUSH) ? CONFIG.rushSpeed : CONFIG.maxSpeed;
        p.speed += CONFIG.accel * (game.state === STATE.RUSH ? 10 : 1);
        if (p.speed > maxS) p.speed = maxS;
        p.z += p.speed * dt;

        let speedRatio = (p.speed / CONFIG.maxSpeed);
        // 【修正手感】提高基础转向系数
        let dx = dt * (3.5 * speedRatio + 1.2);
        if (game.state === STATE.RUSH) dx *= 1.5;

        if (game.keys.left) p.x -= dx;
        if (game.keys.right) p.x += dx;

        const currentSeg = game.segments[Math.floor(p.z/CONFIG.segL) % game.segments.length];
        // 离心力
        p.x -= (dx * speedRatio * currentSeg.curve * CONFIG.centrifugal);

        const currentRoadLimit = (CONFIG.roadW / CONFIG.laneW) * SETTINGS.roadWidthScale - 0.1;
        if (p.x < -currentRoadLimit) { p.x = -currentRoadLimit; if(p.speed>8000) p.speed-=200; }
        if (p.x > currentRoadLimit) { p.x = currentRoadLimit; if(p.speed>8000) p.speed-=200; }

        game.cars.forEach(car => {
            car.z += car.speed * dt;
            if (Math.abs(car.z - p.z) < 300 && Math.abs(car.x - p.x) < 0.7) handleCollision(car, 'car', currentSeg);
        });
        currentSeg.sprites.forEach((s, i) => {
            if (Math.abs(p.x - s.x) < 0.7) { handleCollision(s, 'obs', currentSeg); }
        });

        // 移除已销毁对象
        game.cars = game.cars.filter(c => c.active !== false);
        game.segments.forEach(seg => {
            seg.sprites = seg.sprites.filter(s => s.active !== false);
        });

        if (game.state === STATE.RUSH) {
            p.rage -= dt * 20;
            p.score += 2000 * dt;
            if (p.rage <= 0) exitRushMode();
        } else {
            p.rage = Math.max(0, p.rage - dt * CONFIG.rageDrain);
            if (p.rage >= 100) enterRushMode();
        }

        if (game.cam.shake > 0) game.cam.shake = Math.max(0, game.cam.shake - dt*100);
        speedTier = getSpeedTier(p.speed);
        updateUI();
        updateParticles(dt);
    }

    function getSpeedTier(v){
        if (v > 10000) return 3;
        if (v > 7000) return 2;
        if (v > 4000) return 1;
        return 0;
    }

    // --- 碰撞处理 (对象消失逻辑) ---
    function handleCollision(target, type, segRef) {
        const p = game.player;
        const isRush = game.state === STATE.RUSH;
        game.cam.shake = isRush ? 15 : 30;

        target.active = false;
        if(type === 'car') target.z = -99999;

        const hitPos = screenPosFromTarget(target, segRef);
        spawnExplosion(hitPos.x, hitPos.y, 50, isRush ? '#0ff' : (type==='obs'?'#fa0':'#f00'));
        spawnSmoke(hitPos.x, hitPos.y, 40);
        playExplosionSound(isRush ? 0.8 : 1.2);

        if (isRush) {
            p.score += 5000; p.kills++; showMsg("DESTROYED", "+5000");
        } else {
            p.speed *= 0.6;
            game.player.rage += CONFIG.ragePerHit;
            showMsg("IMPACT", "SPEED LOST");
        }
    }

    function enterRushMode() {
        game.state = STATE.RUSH;
        document.getElementById('game-container').classList.add('rush-active');
        document.getElementById('rage-container').classList.add('full');
        showMsg("HYPER DRIVE", "ENGAGED");
    }
    function exitRushMode() {
        game.state = STATE.PLAY;
        game.player.rage = 0;
        document.getElementById('game-container').classList.remove('rush-active');
        document.getElementById('rage-container').classList.remove('full');
    }

    // --- 粒子与特效 ---
    function updateParticles(dt) {
        for(let i=game.particles.length-1; i>=0; i--) {
            let pt = game.particles[i];
            pt.x += pt.vx; pt.y += pt.vy; pt.life -= dt; pt.vy += 5*dt;
            if(pt.life <= 0) game.particles.splice(i,1);
        }
    }
    function renderParticles() {
        game.particles.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life;
            ctx.fillRect(p.x, p.y, p.size, p.size);
        });
        ctx.globalAlpha = 1;
    }
    function spawnExplosion(x,y,n,c) {
        for(let i=0;i<n;i++) {
            const a = Math.random()*6.28, s = Math.random()*15+5;
            game.particles.push({x:x,y:y,vx:Math.cos(a)*s,vy:Math.sin(a)*s,life:Math.random(),color:c,size:Math.random()*6+2});
        }
    }
    function spawnSmoke(x,y,n){
        for(let i=0;i<n;i++){
            const a = Math.random()*6.28, s = Math.random()*8;
            game.particles.push({x:x,y:y,vx:Math.cos(a)*s*0.5,vy:Math.sin(a)*s*0.5 - 2,life:0.8+Math.random()*0.6,color:'rgba(80,80,80,0.8)',size:Math.random()*10+6});
        }
    }
    function drawSpeedFX(tier){
        if(tier<=0) return;
        const lines = 25 * tier;
        ctx.save();
        ctx.globalAlpha = 0.12 + tier*0.05;
        ctx.strokeStyle = 'rgba(0,255,255,0.6)';
        ctx.lineWidth = 2 + tier;
        for(let i=0;i<lines;i++){
            const ang = Math.random()*Math.PI*2;
            const len = 80 + Math.random()*120 + tier*40;
            const r = Math.random()*Math.min(W,H)*0.6 + Math.min(W,H)*0.25;
            const x = W/2 + Math.cos(ang)*r;
            const y = H/2 + Math.sin(ang)*r;
            ctx.beginPath();
            ctx.moveTo(x,y);
            ctx.lineTo(x - Math.cos(ang)*len, y - Math.sin(ang)*len);
            ctx.stroke();
        }
        ctx.restore();
    }

    function screenPosFromTarget(target, segRef){
        const laneW = CONFIG.laneW * SETTINGS.roadWidthScale;
        const seg = segRef || game.segments[(Math.floor((target.z||game.player.z)/CONFIG.segL)) % game.segments.length];
        const wz = target.z || (seg ? seg.p1.world.z : game.player.z);
        const wy = seg ? seg.p1.world.y : 0;
        const offsetZ = wz - game.player.z;
        const temp = { world:{ y: wy, z: wz }, camera:{}, screen:{} };
        project(temp, (target.x||0) * laneW, offsetZ);
        return { x: temp.screen.x, y: temp.screen.y };
    }

    function updateUI() {
        document.getElementById('score-val').innerText = Math.floor(game.player.score);
        document.getElementById('speed-val').innerText = Math.floor(game.player.speed/100);
        document.getElementById('kill-val').innerText = game.player.kills;
        document.getElementById('rage-fill').style.width = game.player.rage + '%';
    }
    function showMsg(m,s,t=1000) {
        const el = document.getElementById('center-msg');
        el.innerHTML = `<div class="msg-big">${m}</div><div class="msg-sub">${s}</div>`;
        el.style.display = 'block';
        clearTimeout(game.msgTimer);
        game.msgTimer = setTimeout(()=>el.style.display='none', t);
    }

    // --- 渲染逻辑 ---
    function render() {
        ctx.fillStyle = game.state === STATE.RUSH ? '#100' : CONFIG.colors.sky;
        ctx.fillRect(0,0,W,H);
        drawSpeedFX(speedTier);
        let sx = (Math.random()-0.5)*game.cam.shake, sy = (Math.random()-0.5)*game.cam.shake;
        ctx.save(); ctx.translate(sx, sy);

        const baseIdx = Math.floor(game.player.z/CONFIG.segL);
        let maxY = H;

        for(let n=0; n<CONFIG.drawDist; n++) {
            const segment = game.segments[(baseIdx + n) % game.segments.length];
            const loopedIdx = (segment.index < baseIdx) ? segment.index + game.segments.length : segment.index;
            const offsetZ = (loopedIdx * CONFIG.segL) - game.player.z;
            if(offsetZ < CONFIG.camD) continue;
            const currentLaneW = CONFIG.laneW * SETTINGS.roadWidthScale;
            project(segment.p1, game.player.x * currentLaneW, offsetZ);
            project(segment.p2, game.player.x * currentLaneW - (segment.curve * (offsetZ/CONFIG.segL)), offsetZ+CONFIG.segL);
            if(segment.p1.screen.y >= maxY) continue;
            renderRoad(segment);
            maxY = segment.p1.screen.y;
        }

        for(let n=CONFIG.drawDist-1; n>0; n--) {
            const segment = game.segments[(baseIdx + n) % game.segments.length];
            const currentLaneW = CONFIG.laneW * SETTINGS.roadWidthScale;
            segment.buildings.forEach(b => renderBuilding3D(segment, b, currentLaneW));

            game.cars.forEach(car => {
                if(car.z >= segment.p1.world.z && car.z < segment.p2.world.z) {
                    const pct = (car.z - segment.p1.world.z) / CONFIG.segL;
                    renderCarModel(segment, car, currentLaneW, pct);
                }
            });
            segment.sprites.forEach(s => {
                renderObstacleModel(segment, s, currentLaneW, 0);
            });
        }

        renderPlayer();
        renderParticles();
        ctx.restore();
    }

    function project(p, cx, cz) {
        p.camera.x = p.world.x || 0;
        p.camera.y = (p.world.y || 0) - CONFIG.camH;
        p.camera.z = cz;
        p.screen.scale = CONFIG.camD / cz;
        p.screen.x = Math.round((W/2) + (p.screen.scale * (-cx) * W/2));
        p.screen.y = Math.round((H*0.5) - (p.screen.scale * p.camera.y * H/2));
        p.screen.w = Math.round(p.screen.scale * CONFIG.roadW * SETTINGS.roadWidthScale * W/2);
    }

    function renderRoad(s) {
        const p1=s.p1.screen, p2=s.p2.screen;
        const col = game.state===STATE.RUSH ? (Math.floor(s.index/2)%2?'#f0f':'#0ff') : s.color;
        ctx.fillStyle = game.state===STATE.RUSH?'#000':(Math.floor(s.index/5)%2?CONFIG.colors.grassDark:CONFIG.colors.grassLight);
        ctx.fillRect(0, p2.y, W, p1.y-p2.y);
        ctx.fillStyle = col;
        ctx.beginPath();
        ctx.moveTo(p1.x-p1.w, p1.y); ctx.lineTo(p1.x+p1.w, p1.y);
        ctx.lineTo(p2.x+p2.w, p2.y); ctx.lineTo(p2.x-p2.w, p2.y);
        ctx.fill();
        ctx.fillStyle = '#fff';
        const mw = p1.w * 0.05;
        ctx.fillRect(p1.x-p1.w-mw, p1.y, mw, p1.y-p2.y);
        ctx.fillRect(p1.x+p1.w, p1.y, mw, p1.y-p2.y);
    }

    function renderBuilding3D(s, b, laneW) {
        const scale = s.p1.screen.scale;
        const screenX = s.p1.screen.x + (scale * b.x * laneW * W / 2);
        const screenY = s.p1.screen.y;
        const buildW = b.w * laneW * scale * W / 2;
        const buildH = b.h * scale * H / 2;

        if (buildW < 2 || buildH < 2) return;
        if (screenX + buildW < 0 || screenX - buildW > W) return;

        const palette = PALETTES[Math.floor((b.c || 0) * PALETTES.length) % PALETTES.length];

        ctx.save();
        ctx.translate(screenX, screenY);

        const hue = Math.floor(b.c * 360);
        const grd = ctx.createLinearGradient(0, -buildH, 0, 0);
        grd.addColorStop(0, `hsla(${hue}, 100%, 70%, 1)`);
        grd.addColorStop(0.3, `hsla(${hue}, 60%, 20%, 1)`);
        grd.addColorStop(1, '#000');

        ctx.fillStyle = grd;
        ctx.fillRect(-buildW/2, -buildH, buildW, buildH);
        ctx.strokeStyle = `hsla(${hue}, 100%, 50%, 0.8)`;
        ctx.lineWidth = 1;
        ctx.strokeRect(-buildW/2, -buildH, buildW, buildH);
        if (b.type === 'tower') {
            ctx.fillStyle = `hsla(${hue},100%,80%,1)`;
            ctx.fillRect(-2, -buildH-10, 4, 10);
        }
        ctx.restore();
    }

    // --- 【包含DEBUG】车辆渲染 ---
    function renderCarModel(s, car, laneW, pct) {
        const p1 = s.p1.screen, p2 = s.p2.screen;
        const scale = p1.scale + (p2.scale - p1.scale) * pct;
        const sx = p1.x + (p2.x - p1.x) * pct + (scale * car.x * laneW * W / 2);
        const sy = p1.y + (p2.y - p1.y) * pct;

        const style = CAR_STYLES[car.style] || CAR_STYLES['sedan'];
        const w = style.w * scale * W / 2;
        const h = style.h * scale * H / 2;

        ctx.save();
        ctx.translate(sx, sy);

        // 阴影
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(-w/2 - w*0.1, 0, w*1.2, h*0.15);

        // 视差侧面
        const parallax = (sx - W/2) / (W/2);
        const depth = w * 0.4;

        ctx.fillStyle = '#111';
        if (Math.abs(parallax) > 0.1) {
            ctx.beginPath();
            if (parallax > 0) { ctx.moveTo(-w/2, -h); ctx.lineTo(-w/2, 0); ctx.lineTo(-w/2 - depth*parallax, -h*0.2); ctx.lineTo(-w/2 - depth*parallax, -h*0.8); }
            else { ctx.moveTo(w/2, -h); ctx.lineTo(w/2, 0); ctx.lineTo(w/2 - depth*parallax, -h*0.2); ctx.lineTo(w/2 - depth*parallax, -h*0.8); }
            ctx.fill();
        }

        // 车身
        const colVar = car.colorVar > 0.5 ? '#444' : style.color;
        ctx.fillStyle = colVar;
        if (car.style === 'truck') { ctx.fillRect(-w/2, -h, w, h); ctx.fillStyle = '#000'; ctx.fillRect(-w/2+5, -h+10, w-10, h/2); }
        else if (car.style === 'racer') { ctx.beginPath(); ctx.moveTo(-w/2, 0); ctx.lineTo(w/2, 0); ctx.lineTo(w/3, -h); ctx.lineTo(-w/3, -h); ctx.fill(); }
        else { ctx.fillRect(-w/2, -h*0.6, w, h*0.6); ctx.fillRect(-w/3, -h, w*0.66, h*0.4); }

        // 尾灯
        ctx.shadowBlur = 10 * scale * 20;
        ctx.shadowColor = '#f00';
        ctx.fillStyle = '#f00';
        if (style.lights === 'v-side') { ctx.fillRect(-w/2 + 2, -h + 10, w*0.1, h*0.8); ctx.fillRect(w/2 - w*0.1 - 2, -h + 10, w*0.1, h*0.8); }
        else if (style.lights === 'quad') { ctx.beginPath(); ctx.arc(-w/3, -h/3, h/6, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(w/3, -h/3, h/6, 0, Math.PI*2); ctx.fill(); }
        else { ctx.fillRect(-w/2 + 5, -h/2, w-10, h/5); }
        ctx.shadowBlur = 0;

        // DEBUG BOX
        const hitLimit = 0.7;
        const hitScreenW = hitLimit * laneW * scale * W / 2;
        ctx.strokeStyle = '#0f0'; ctx.lineWidth = 2;
        ctx.strokeRect(-hitScreenW, -h*1.2, hitScreenW*2, h*1.4);
        ctx.fillStyle = '#fff'; ctx.fillRect(-2, -2, 4, 4);
        ctx.fillStyle = '#0f0'; ctx.font = '10px monospace';
        const distZ = Math.floor(car.z - game.player.z);
        ctx.fillText(`Z:${distZ}`, -hitScreenW, -h*1.3);

        ctx.restore();
    }

    // --- 【包含DEBUG】障碍物渲染 ---
    function renderObstacleModel(s, obj, laneW, pct) {
        const p1 = s.p1.screen;
        const scale = p1.scale;
        const sx = p1.x + (scale * obj.x * laneW * W / 2);
        const sy = p1.y;

        const style = OBS_STYLES[obj.style] || OBS_STYLES['crate'];
        const sizeMult = obj.size || 1;
        const w = style.w * scale * W / 2 * sizeMult;
        const h = style.h * scale * H / 2 * sizeMult;

        if (w < 2) return;

        ctx.save();
        ctx.translate(sx, sy);

        const parallax = (sx - W/2) / (W/2);
        const depthX = parallax * w * 0.5;
        const topY = -h * 0.8;

        if (style.type === 'box') {
            ctx.fillStyle = style.color; ctx.fillRect(-w/2, -h, w, h);
            ctx.fillStyle = '#ffaa00'; ctx.beginPath(); ctx.moveTo(-w/2, -h); ctx.lineTo(w/2, -h); ctx.lineTo(w/2 + depthX, -h + topY); ctx.lineTo(-w/2 + depthX, -h + topY); ctx.fill();
            ctx.fillStyle = '#aa4400'; ctx.beginPath();
            if (parallax > 0) { ctx.moveTo(-w/2, -h); ctx.lineTo(-w/2, 0); ctx.lineTo(-w/2 + depthX, topY); ctx.lineTo(-w/2 + depthX, -h + topY); }
            else { ctx.moveTo(w/2, -h); ctx.lineTo(w/2, 0); ctx.lineTo(w/2 + depthX, topY); ctx.lineTo(w/2 + depthX, -h + topY); }
            ctx.fill();
            ctx.strokeStyle = '#000'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(-w/2, -h); ctx.lineTo(w/2, 0); ctx.stroke(); ctx.beginPath(); ctx.moveTo(w/2, -h); ctx.lineTo(-w/2, 0); ctx.stroke();
        } else if (style.type === 'trap') {
            ctx.fillStyle = '#888'; ctx.beginPath(); ctx.moveTo(-w/2, 0); ctx.lineTo(w/2, 0); ctx.lineTo(w/3, -h); ctx.lineTo(-w/3, -h); ctx.fill();
            ctx.fillStyle = '#555'; ctx.beginPath();
            if(parallax > 0) { ctx.moveTo(-w/2, 0); ctx.lineTo(-w/3, -h); ctx.lineTo(-w/3+depthX, -h-20); ctx.lineTo(-w/2+depthX, -20); }
            else { ctx.moveTo(w/2, 0); ctx.lineTo(w/3, -h); ctx.lineTo(w/3+depthX, -h-20); ctx.lineTo(w/2+depthX, -20); }
            ctx.fill();
        } else {
            ctx.shadowBlur = 20; ctx.shadowColor = style.color; ctx.fillStyle = style.color;
            ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(w/2, -h/2); ctx.lineTo(0, -h); ctx.lineTo(-w/2, -h/2); ctx.fill();
            ctx.fillStyle = '#fff'; ctx.globalAlpha = 0.5; ctx.beginPath(); ctx.moveTo(0, -h); ctx.lineTo(10, -h/2); ctx.lineTo(0, 0); ctx.fill(); ctx.shadowBlur = 0; ctx.globalAlpha = 1;
        }

        // DEBUG BOX
        const hitLimit = 0.7;
        const hitScreenW = hitLimit * laneW * scale * W / 2;
        ctx.strokeStyle = '#0f0'; ctx.lineWidth = 2;
        ctx.strokeRect(-hitScreenW, -h*1.2, hitScreenW*2, h*1.4);
        ctx.fillStyle = '#fff'; ctx.fillRect(-2, -2, 4, 4);

        ctx.restore();
    }

    // --- 玩家渲染 ---
    function renderPlayer() {
        const carW = 200, carH = 100;
        const x = W/2, y = H - 80; // TPP 视角下移
        ctx.save(); ctx.translate(x, y);
        let tilt = game.keys.left ? -0.05 : (game.keys.right ? 0.05 : 0);
        ctx.rotate(tilt);
        ctx.fillStyle = '#111'; ctx.fillRect(-carW/2, -carH, carW, carH);
        ctx.fillStyle = '#222'; ctx.beginPath(); ctx.moveTo(-carW/2 + 20, -carH); ctx.lineTo(carW/2 - 20, -carH); ctx.lineTo(carW/2 - 40, -carH - 40); ctx.lineTo(-carW/2 + 40, -carH - 40); ctx.fill();
        const lightW = 40, lightH = 20;
        ctx.shadowBlur = 20; ctx.shadowColor = '#f00'; ctx.fillStyle = '#f00';
        ctx.fillRect(-carW/2 + 10, -carH + 20, lightW, lightH); ctx.fillRect(carW/2 - 10 - lightW, -carH + 20, lightW, lightH);
        if(game.player.speed > 5000) { ctx.shadowColor = '#0ff'; ctx.fillStyle = '#0ff'; const h = (game.player.speed / CONFIG.maxSpeed) * 60; ctx.globalAlpha = 0.6; ctx.fillRect(-20, -10, 10, h); ctx.fillRect(10, -10, 10, h); }

        // DEBUG PLAYER CENTER
        ctx.shadowBlur = 0; ctx.strokeStyle = '#ff0';
        ctx.beginPath(); ctx.moveTo(-10, 0); ctx.lineTo(10, 0); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, -10); ctx.lineTo(0, 10); ctx.stroke();

        ctx.restore();
    }

    function initAudio() {
        const AC = window.AudioContext || window.webkitAudioContext;
        game.audio = new AC();
        const osc = game.audio.createOscillator();
        const gain = game.audio.createGain();
        osc.type = 'sawtooth'; osc.frequency.value=50; gain.gain.value=0.1;
        osc.connect(gain); gain.connect(game.audio.destination); osc.start();
        setInterval(()=>{
            const freq = 50 + (game.player.speed/CONFIG.maxSpeed)*200;
            osc.frequency.setTargetAtTime(freq, game.audio.currentTime, 0.1);
            gain.gain.value = (game.state===STATE.MENU)?0:0.1;
        }, 100);
    }
    function playExplosionSound(intensity=1){
        try{
            if(!game.audio) return;
            const ctxA = game.audio;
            const buffer = ctxA.createBuffer(1, ctxA.sampleRate*0.25, ctxA.sampleRate);
            const data = buffer.getChannelData(0);
            for(let i=0;i<data.length;i++){
                const t = i/data.length;
                data[i] = (Math.random()*2-1)*Math.pow(1-t,2.4)*intensity;
            }
            const src = ctxA.createBufferSource(); src.buffer=buffer;
            const gain = ctxA.createGain(); gain.gain.value=0.6*intensity;
            const bp = ctxA.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=180+intensity*180;
            src.connect(bp).connect(gain).connect(ctxA.destination);
            src.start();
        }catch(e){}
    }
    init();
</script>
</body>
</html>