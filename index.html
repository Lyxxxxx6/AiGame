<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>CYBER RUSH: OPTIMIZED</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        body { margin: 0; overflow: hidden; background: #050510; color: #fff; font-family: 'Orbitron', sans-serif; user-select: none; }
        #game-container { position: relative; width: 100vw; height: 100vh; overflow: hidden;}
        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }
        
        /* UI 层保持不变 */
        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #hud-top { display: flex; justify-content: space-between; padding: 30px; font-weight: 900; letter-spacing: 2px; text-shadow: 0 0 10px #0ff; }
        .stat-value { font-size: 40px; color: #fff; text-shadow: 2px 2px 0 #f0f; }
        #speed-container { position: absolute; top: 10%; left: 50%; transform: translateX(-50%) skew(-10deg); text-align: center; }
        #speed-val { font-size: 100px; line-height: 80px; font-weight: 900; background: linear-gradient(to bottom, #fff, #888); -webkit-background-clip: text; -webkit-text-fill-color: transparent; filter: drop-shadow(0 0 15px #0ff); }
        #speed-unit { font-size: 24px; color: #0ff; letter-spacing: 5px; }
        #rage-container { position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%); width: 600px; height: 40px; border: 4px solid #fff; transform: skew(-20deg); box-shadow: 0 0 30px #f00; background: rgba(0,0,0,0.5); }
        #rage-fill { width: 0%; height: 100%; background: repeating-linear-gradient(45deg, #f00, #f00 10px, #900 10px, #900 20px); transition: width 0.05s linear; }
        #center-msg { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); text-align: center; white-space: nowrap; z-index: 10; display: none; text-shadow: 0 0 20px #f00;}
        .msg-big { font-size: 120px; font-weight: 900; color: #fff; -webkit-text-stroke: 4px #000; }
        .msg-sub { font-size: 40px; color: #0ff; background: #000; padding: 5px 20px; }
        
        /* 菜单样式 */
        #menu-layer { background: rgba(0,0,0,0.85); backdrop-filter: blur(10px); display: flex; flex-direction: column; justify-content: center; align-items: center; pointer-events: auto; }
        .glitch-title { font-size: 80px; font-weight: 900; color: #fff; text-shadow: 4px 0 #f00, -4px 0 #0ff; margin-bottom: 20px; }
        .menu-view { display: flex; flex-direction: column; align-items: center; width: 100%; transition: opacity 0.3s; }
        .settings-box { background: rgba(0,20,40,0.9); border: 1px solid #0ff; padding: 30px; margin-bottom: 20px; width: 600px; text-align: left; box-shadow: 0 0 30px rgba(0,255,255,0.1); border-radius: 4px; }
        .setting-item { margin-bottom: 25px; }
        .setting-label { color: #fff; font-size: 18px; display:flex; justify-content:space-between; margin-bottom: 8px; font-weight: 700;}
        input[type=range] { width: 100%; height: 6px; background: #333; outline: none; -webkit-appearance: none; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; background: #0ff; cursor: pointer; border: 2px solid #fff; box-shadow: 0 0 10px #0ff; }
        button { background: #000; border: 2px solid #0ff; color: #0ff; padding: 15px 40px; margin: 10px; font-size: 24px; font-family: 'Orbitron'; cursor: pointer; text-transform: uppercase; transition: 0.2s; position: relative; overflow: hidden; width: 400px; }
        button:hover { background: #0ff; color: #000; box-shadow: 0 0 30px #0ff; }
    </style>
</head>
<body>
<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div id="warp-overlay"></div>
    <div id="hud" class="ui-layer" style="display: none;">
        <div id="hud-top">
            <div class="stat-group"><div class="stat-label">SCORE</div><div id="score-val" class="stat-value">0</div></div>
            <div class="stat-group" style="align-items: flex-end;"><div class="stat-label">KILLS</div><div id="kill-val" class="stat-value" style="color:#f33">0</div></div>
        </div>
        <div id="speed-container">
            <div id="speed-val">0</div>
            <div id="speed-unit">KM/H</div>
        </div>
        <div id="center-msg"></div>
        <div id="rage-container"><div id="rage-fill"></div></div>
    </div>
    <div id="menu-layer" class="ui-layer">
        <div class="glitch-title">CYBER RUSH</div>
        <div id="view-main" class="menu-view">
            <button onclick="startGame()">启动引擎</button>
            <button onclick="switchView('settings')">系统设置</button>
        </div>
        <div id="view-settings" class="menu-view" style="display: none;">
            <div class="settings-box">
                <h3 style="color: #0ff; border-bottom: 1px solid #444; padding-bottom: 10px; margin-top: 0;">赛道生成参数</h3>
                <div class="setting-item">
                    <label class="setting-label">建筑密度 <span id="val-den" style="color:#0f0">中等</span></label>
                    <input type="range" id="set-den" min="0" max="10" value="5">
                </div>
                <div class="setting-item">
                    <label class="setting-label">赛道宽度 <span id="val-road" style="color:#0f0">100%</span></label>
                    <input type="range" id="set-road" min="50" max="150" value="100">
                </div>
                <h3 style="color: #f0f; border-bottom: 1px solid #444; padding-bottom: 10px; margin-top: 30px;">游戏参数</h3>
                <div class="setting-item">
                    <label class="setting-label">车流密度 <span id="val-traf" style="color:#f0f">2%</span></label>
                    <input type="range" id="set-traf" min="0" max="10" value="2">
                </div>
                <div class="setting-item">
                    <label class="setting-label">车流速度 <span id="val-spd" style="color:#ff0">正常</span></label>
                    <input type="range" id="set-spd" min="1" max="5" value="2">
                </div>
            </div>
            <button onclick="applySettings()">应用并重启</button>
            <button onclick="switchView('main')" style="border-color:#666; color:#888;">返回</button>
        </div>
    </div>
</div>

<script>
    // --- 基础常量 ---
    const CONFIG = {
        segL: 200,
        laneW: 2400,        
        roadW: 2200,        
        camH: 5500,         // 【修改】抬高相机，形成第三人称视角
        camD: 0.95,
        drawDist: 500,
        accel: 100,         // 【修改】加速度微调
        maxSpeed: 14000,    // 【修改】最大速度提升
        rushSpeed: 120000,
        rageDrain: 5,
        ragePerHit: 8,
        centrifugal: 0.35,  // 【新增】离心力系数
        colors: {
            sky: '#050510',
            roadDark: '#101015', roadLight: '#181820',
            grassDark: '#020205', grassLight: '#040408'
        }
    };
    const SETTINGS = {
        roadWidthScale: 1.0,
        buildDensity: 0.5,
        carDensity: 0.02,
        carSpeedMult: 1.0
    };
    const STATE = { MENU: 0, PLAY: 1, RUSH: 2 };
    // 霓虹调色盘
    const PALETTES = [
        { base: '#1a0033', light: '#d0f' },
        { base: '#001a33', light: '#0ff' },
        { base: '#331a00', light: '#fa0' },
        { base: '#00331a', light: '#0f6' },
        { base: '#222',    light: '#fff' }
    ];
    let game = {
        state: STATE.MENU,
        time: 0, dt: 0,
        segments: [], cars: [], particles: [],
        player: { x: 0, z: 0, speed: 0, score: 0, rage: 0, kills: 0 },
        keys: { left: false, right: false },
        cam: { shake: 0 },
        audio: null
    };
    let speedTier = 0;
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    let W, H;

    function init() {
        resize();
        window.addEventListener('resize', resize);
        window.addEventListener('keydown', e => {
            if(e.key === 'ArrowLeft' || e.key === 'a') game.keys.left = true;
            if(e.key === 'ArrowRight' || e.key === 'd') game.keys.right = true;
        });
        window.addEventListener('keyup', e => {
            if(e.key === 'ArrowLeft' || e.key === 'a') game.keys.left = false;
            if(e.key === 'ArrowRight' || e.key === 'd') game.keys.right = false;
        });
        bindUI();
    }
    
    // UI绑定保持不变
    function bindUI() {
        const denInput = document.getElementById('set-den');
        denInput.oninput = function() {
            SETTINGS.buildDensity = this.value / 10;
            let txt = "稀疏";
            if(this.value > 3) txt = "中等";
            if(this.value > 7) txt = "密集";
            if(this.value == 10) txt = "摩天林立";
            document.getElementById('val-den').innerText = txt;
        };
        const roadInput = document.getElementById('set-road');
        roadInput.oninput = function() {
            SETTINGS.roadWidthScale = this.value / 100;
            document.getElementById('val-road').innerText = this.value + "%";
        };
        const trafInput = document.getElementById('set-traf');
        trafInput.oninput = function() {
            SETTINGS.carDensity = this.value / 100;
            document.getElementById('val-traf').innerText = this.value + "%";
        };
        const spdInput = document.getElementById('set-spd');
        spdInput.oninput = function() {
            const val = parseInt(this.value);
            SETTINGS.carSpeedMult = [0.5, 1.0, 1.5, 2.0, 3.0][val - 1];
            document.getElementById('val-spd').innerText = ["缓慢", "正常", "快速", "狂暴", "封顶"][val - 1];
        };
    }
    function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
    function switchView(name) {
        document.getElementById('view-main').style.display = name === 'main' ? 'flex' : 'none';
        document.getElementById('view-settings').style.display = name === 'settings' ? 'flex' : 'none';
    }
    function applySettings() { startGame(); }

    function startGame() {
        if (!game.audio) initAudio();
        game.segments = [];
        game.cars = [];
        game.particles = [];
        game.player = { x: 0, z: 0, speed: 0, score: 0, rage: 0, kills: 0 };
        game.state = STATE.PLAY;
        generateTrack();
        document.getElementById('menu-layer').style.display = 'none';
        document.getElementById('hud').style.display = 'block';
        document.getElementById('game-container').classList.remove('rush-active');
        showMsg("引擎点火", "RACE START", 2000);
        gameLoop(0);
    }

    // 【修改】道路程序化生成 - 增加起伏和状态机弯道
    function generateTrack() {
        game.segments = [];
        const totalSegs = 4000;
        const roadEdgeNorm = (CONFIG.roadW / CONFIG.laneW);
        let buildAccumulator = 0;
        
        // 赛道状态机
        let currentHeight = 0;
        let currentCurve = 0;
        let sectionType = 'straight'; // straight, curve, hill
        let sectionLeft = 0;

        function addSegment(index, curve, y) {
            const buildings = [];
            buildAccumulator += SETTINGS.buildDensity;
            // 建筑生成逻辑
            if (buildAccumulator > 1.0 + Math.random()) {
                buildAccumulator = 0;
                const isLandmark = Math.random() < 0.05;
                buildings.push(createBuilding(-1, roadEdgeNorm, isLandmark, index/totalSegs));
                buildings.push(createBuilding(1, roadEdgeNorm, isLandmark, index/totalSegs));
            }
            const sprites = [];
            if (index > 50 && Math.random() < 0.03) {
                const safeZone = roadEdgeNorm * 0.8;
                sprites.push({ type: 'block', x: (Math.random()*2 - 1) * safeZone });
            }
            if (index > 50 && Math.random() < SETTINGS.carDensity) {
                let speed = (3000 + Math.random()*2000) * SETTINGS.carSpeedMult;
                const safeZone = roadEdgeNorm * 0.8;
                game.cars.push({ z: index * CONFIG.segL, x: (Math.random()*2-1)*safeZone, speed: speed, active: true });
            }

            game.segments.push({
                index: index,
                p1: { world: { y: y, z: index*CONFIG.segL }, camera: {}, screen: {} },
                p2: { world: { y: y, z: (index+1)*CONFIG.segL }, camera: {}, screen: {} },
                curve: curve,
                sprites: sprites,
                buildings: buildings,
                color: Math.floor(index/5)%2 ? CONFIG.colors.roadDark : CONFIG.colors.roadLight
            });
        }

        // 平滑过渡函数
        function easeInOut(t) { return t<.5 ? 2*t*t : -1+(4-2*t)*t; }

        let targetCurve = 0;
        let targetHeight = 0;
        let startHeight = 0;

        for (let i = 0; i < totalSegs; i++) {
            if (sectionLeft <= 0) {
                // 随机决定下一段赛道
                const r = Math.random();
                if (r < 0.3) { // 直道
                    sectionType = 'straight';
                    sectionLeft = 50 + Math.random() * 50;
                    targetCurve = 0;
                    targetHeight = currentHeight;
                } else if (r < 0.7) { // 弯道
                    sectionType = 'curve';
                    sectionLeft = 80 + Math.random() * 100;
                    targetCurve = (Math.random() > 0.5 ? 1 : -1) * (2 + Math.random() * 4); // 随机左或右弯
                    targetHeight = currentHeight;
                } else { // 坡道
                    sectionType = 'hill';
                    sectionLeft = 60 + Math.random() * 60;
                    targetCurve = 0;
                    startHeight = currentHeight;
                    // 随机上坡或下坡，限制最大高度
                    let dir = (Math.random() > 0.5 ? 1 : -1);
                    if (currentHeight > 3000) dir = -1;
                    if (currentHeight < -1000) dir = 1;
                    targetHeight = currentHeight + dir * (2000 + Math.random() * 3000);
                }
            }

            // 执行生成
            let actualCurve = 0;
            if (sectionType === 'curve') {
                // 入弯出弯平滑处理
                const progress = 1 - (sectionLeft / 100); // 粗略估算
                actualCurve = targetCurve;
                if (sectionLeft < 20) actualCurve = targetCurve * (sectionLeft/20); // 出弯
            } else {
                actualCurve = 0;
            }
            
            // 坡度平滑
            if (sectionType === 'hill') {
                 // 简单的插值
                 if (Math.abs(targetHeight - currentHeight) > 10) {
                     currentHeight += (targetHeight - startHeight) / 60; // 渐变
                 }
            } else {
                // 慢慢回归水平（可选）
            }

            addSegment(i, actualCurve, currentHeight);
            sectionLeft--;
        }
        
        // 修复坡道接缝
        for(let i=0; i<totalSegs-1; i++) {
            game.segments[i].p2.world.y = game.segments[i+1].p1.world.y;
        }
    }

    function randRange(a,b){ return a + Math.random()*(b-a); }
    function createBuilding(side, roadEdgeNorm, isLandmark, progress){
        // 保持原来的参数逻辑，渲染时再优化
        const width = isLandmark ? randRange(4.2,5.5) : randRange(1.2,3.5);
        const heightBase = isLandmark ? randRange(12000,20000) : randRange(4000,12000);
        const speedBoost = 1 + progress * 0.6;
        const height = heightBase * speedBoost;
        const buffer = 0.2 + Math.random()*0.25;
        const x = side * (roadEdgeNorm + buffer + width/2);
        const type = isLandmark ? ['mega','tower','gate'][Math.floor(Math.random()*3)] : 'normal';
        return { x, w: width, h: height, c: Math.random(), type, seed: Math.random() };
    }

    let lastTime = 0;
    function gameLoop(time) {
        if (game.state === STATE.MENU) return;
        const dt = Math.min(0.1, (time - lastTime) / 1000);
        lastTime = time;
        update(dt);
        render();
        requestAnimationFrame(gameLoop);
    }

    // 【修改】手感优化 - 物理与输入
    function update(dt) {
        const p = game.player;
        const maxS = (game.state === STATE.RUSH) ? CONFIG.rushSpeed : CONFIG.maxSpeed;
        
        // 加速度
        p.speed += CONFIG.accel * (game.state === STATE.RUSH ? 10 : 1);
        if (p.speed > maxS) p.speed = maxS;
        
        // 前进
        p.z += p.speed * dt;
        
        // 转向系数 - 速度越快转向越慢（防抖），但RUSH模式下很灵敏
        let speedRatio = (p.speed / CONFIG.maxSpeed);
        let dx = dt * (2.0 * speedRatio + 0.5); 
        if (game.state === STATE.RUSH) dx *= 1.5;

        // 玩家输入直接控制左右移动
        if (game.keys.left) p.x -= dx;
        if (game.keys.right) p.x += dx;

        const currentSeg = game.segments[Math.floor(p.z/CONFIG.segL) % game.segments.length];
        
        // 【关键】离心力：弯道会把车往反方向推。
        // currentSeg.curve 是正数(右弯)时，p.x 减去一个值(向左移)
        p.x -= (dx * speedRatio * currentSeg.curve * CONFIG.centrifugal);

        // 道路边界限制 (保持原来的逻辑，防止出界)
        const currentRoadLimit = (CONFIG.roadW / CONFIG.laneW) * SETTINGS.roadWidthScale - 0.1;
        
        // 撞墙减速反馈
        if (p.x < -currentRoadLimit) { 
            p.x = -currentRoadLimit; 
            if(p.speed > 8000) p.speed -= 200; // 摩擦减速
        }
        if (p.x > currentRoadLimit) { 
            p.x = currentRoadLimit; 
            if(p.speed > 8000) p.speed -= 200; 
        }

        // 碰撞检测逻辑保持不变
        game.cars.forEach(car => {
            car.z += car.speed * dt;
            if (Math.abs(car.z - p.z) < 300 && Math.abs(car.x - p.x) < 0.7) handleCollision(car, 'car', currentSeg);
        });
        currentSeg.sprites.forEach((s, i) => {
            if (Math.abs(p.x - s.x) < 0.7) { handleCollision(s, 'obs', currentSeg); currentSeg.sprites.splice(i, 1); }
        });
        
        game.cars = game.cars.filter(c => c.active !== false);
        
        // RAGE 系统
        if (game.state === STATE.RUSH) {
            p.rage -= dt * 20;
            p.score += 2000 * dt;
            if (p.rage <= 0) exitRushMode();
        } else {
            p.rage = Math.max(0, p.rage - dt * CONFIG.rageDrain);
            if (p.rage >= 100) enterRushMode();
        }
        
        if (game.cam.shake > 0) game.cam.shake = Math.max(0, game.cam.shake - dt*100);
        speedTier = getSpeedTier(p.speed);
        updateUI();
        updateParticles(dt);
    }

    function getSpeedTier(v){
        if (v > 10000) return 3;
        if (v > 7000) return 2;
        if (v > 4000) return 1;
        return 0;
    }
    
    // 碰撞处理保持不变
    function handleCollision(target, type, segRef) {
        const p = game.player;
        const isRush = game.state === STATE.RUSH;
        game.cam.shake = isRush ? 15 : 30;
        const hitPos = screenPosFromTarget(target, segRef);
        spawnExplosion(hitPos.x, hitPos.y, 40, isRush ? '#0ff' : '#f90');
        spawnSmoke(hitPos.x, hitPos.y, 30);
        playExplosionSound(isRush ? 0.8 : 1.2);
        if (isRush) {
            if (type === 'car') { target.active = false; target.z = -5000; }
            p.score += 5000; p.kills++; showMsg("DESTROYED", "+5000");
        } else {
            p.speed *= 0.6;
            game.player.rage += CONFIG.ragePerHit;
            showMsg("IMPACT", "SPEED LOST");
            if (type === 'car') { target.active = false; target.z = -5000; }
        }
    }
    function enterRushMode() {
        game.state = STATE.RUSH;
        document.getElementById('game-container').classList.add('rush-active');
        document.getElementById('rage-container').classList.add('full');
        showMsg("HYPER DRIVE", "ENGAGED");
    }
    function exitRushMode() {
        game.state = STATE.PLAY;
        game.player.rage = 0;
        document.getElementById('game-container').classList.remove('rush-active');
        document.getElementById('rage-container').classList.remove('full');
    }
    
    // 粒子系统保持不变
    function updateParticles(dt) {
        for(let i=game.particles.length-1; i>=0; i--) {
            let pt = game.particles[i];
            pt.x += pt.vx; pt.y += pt.vy; pt.life -= dt; pt.vy += 5*dt;
            if(pt.life <= 0) game.particles.splice(i,1);
        }
    }
    function renderParticles() {
        game.particles.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life;
            ctx.fillRect(p.x, p.y, p.size, p.size);
        });
        ctx.globalAlpha = 1;
    }
    function spawnExplosion(x,y,n,c) {
        for(let i=0;i<n;i++) {
            const a = Math.random()*6.28, s = Math.random()*15+5;
            game.particles.push({x:x,y:y,vx:Math.cos(a)*s,vy:Math.sin(a)*s,life:Math.random(),color:c,size:Math.random()*6+2});
        }
    }
    function spawnSmoke(x,y,n){
        for(let i=0;i<n;i++){
            const a = Math.random()*6.28, s = Math.random()*8;
            game.particles.push({x:x,y:y,vx:Math.cos(a)*s*0.5,vy:Math.sin(a)*s*0.5 - 2,life:0.8+Math.random()*0.6,color:'rgba(80,80,80,0.8)',size:Math.random()*10+6});
        }
    }
    function drawSpeedFX(tier){
        if(tier<=0) return;
        const lines = 25 * tier;
        ctx.save();
        ctx.globalAlpha = 0.12 + tier*0.05;
        ctx.strokeStyle = 'rgba(0,255,255,0.6)';
        ctx.lineWidth = 2 + tier;
        for(let i=0;i<lines;i++){
            const ang = Math.random()*Math.PI*2;
            const len = 80 + Math.random()*120 + tier*40;
            const r = Math.random()*Math.min(W,H)*0.6 + Math.min(W,H)*0.25;
            const x = W/2 + Math.cos(ang)*r;
            const y = H/2 + Math.sin(ang)*r;
            ctx.beginPath();
            ctx.moveTo(x,y);
            ctx.lineTo(x - Math.cos(ang)*len, y - Math.sin(ang)*len);
            ctx.stroke();
        }
        ctx.restore();
    }
    
    // 投影保持不变
    function screenPosFromTarget(target, segRef){
        const laneW = CONFIG.laneW * SETTINGS.roadWidthScale;
        const seg = segRef || game.segments[(Math.floor((target.z||game.player.z)/CONFIG.segL)) % game.segments.length];
        const wz = target.z || (seg ? seg.p1.world.z : game.player.z);
        const wy = seg ? seg.p1.world.y : 0;
        const offsetZ = wz - game.player.z;
        const temp = { world:{ y: wy, z: wz }, camera:{}, screen:{} };
        project(temp, (target.x||0) * laneW, offsetZ);
        return { x: temp.screen.x, y: temp.screen.y };
    }
    function updateUI() {
        document.getElementById('score-val').innerText = Math.floor(game.player.score);
        document.getElementById('speed-val').innerText = Math.floor(game.player.speed/100);
        document.getElementById('kill-val').innerText = game.player.kills;
        document.getElementById('rage-fill').style.width = game.player.rage + '%';
    }
    function showMsg(m,s,t=1000) {
        const el = document.getElementById('center-msg');
        el.innerHTML = `<div class="msg-big">${m}</div><div class="msg-sub">${s}</div>`;
        el.style.display = 'block';
        clearTimeout(game.msgTimer);
        game.msgTimer = setTimeout(()=>el.style.display='none', t);
    }

    // 渲染主循环
    function render() {
        ctx.fillStyle = game.state === STATE.RUSH ? '#100' : CONFIG.colors.sky;
        ctx.fillRect(0,0,W,H);
        drawSpeedFX(speedTier);
        let sx = (Math.random()-0.5)*game.cam.shake, sy = (Math.random()-0.5)*game.cam.shake;
        ctx.save(); ctx.translate(sx, sy);
        const baseIdx = Math.floor(game.player.z/CONFIG.segL);
        let maxY = H;
        
        // 渲染赛道 (Painter's Algorithm: Back to Front for road)
        for(let n=0; n<CONFIG.drawDist; n++) {
            const segment = game.segments[(baseIdx + n) % game.segments.length];
            const loopedIdx = (segment.index < baseIdx) ? segment.index + game.segments.length : segment.index;
            const offsetZ = (loopedIdx * CONFIG.segL) - game.player.z;
            if(offsetZ < CONFIG.camD) continue;
            const currentLaneW = CONFIG.laneW * SETTINGS.roadWidthScale;
            // 投影时加上 hill (world.y)
            project(segment.p1, game.player.x * currentLaneW, offsetZ);
            project(segment.p2, game.player.x * currentLaneW - (segment.curve * (offsetZ/CONFIG.segL)), offsetZ+CONFIG.segL);
            
            // 遮挡剔除
            if(segment.p1.screen.y >= maxY) continue;
            renderRoad(segment);
            maxY = segment.p1.screen.y;
        }
        
        // 渲染物体 (Back to Front)
        for(let n=CONFIG.drawDist-1; n>0; n--) {
            const segment = game.segments[(baseIdx + n) % game.segments.length];
            const currentLaneW = CONFIG.laneW * SETTINGS.roadWidthScale;
            
            // 渲染建筑
            segment.buildings.forEach(b => renderBuilding3D(segment, b, currentLaneW));
            
            // 渲染车
            game.cars.forEach(car => {
                if(car.z >= segment.p1.world.z && car.z < segment.p2.world.z) {
                    const pct = (car.z - segment.p1.world.z) / CONFIG.segL;
                    renderObject(segment, car.x, currentLaneW, pct, 'car', car);
                }
            });
            // 渲染障碍物
            segment.sprites.forEach(s => renderObject(segment, s.x, currentLaneW, 0, 'block'));
        }
        
        renderPlayer();
        renderParticles();
        ctx.restore();
    }

    function project(p, cx, cz) {
        p.camera.x = p.world.x || 0;
        p.camera.y = (p.world.y || 0) - CONFIG.camH; // 相机高度
        p.camera.z = cz;
        p.screen.scale = CONFIG.camD / cz;
        p.screen.x = Math.round((W/2) + (p.screen.scale * (-cx) * W/2));
        p.screen.y = Math.round((H*0.5) - (p.screen.scale * p.camera.y * H/2)); // 调整视平线
        p.screen.w = Math.round(p.screen.scale * CONFIG.roadW * SETTINGS.roadWidthScale * W/2);
    }

    function renderRoad(s) {
        const p1=s.p1.screen, p2=s.p2.screen;
        const col = game.state===STATE.RUSH ? (Math.floor(s.index/2)%2?'#f0f':'#0ff') : s.color;
        
        // 地面背景
        ctx.fillStyle = game.state===STATE.RUSH?'#000':(Math.floor(s.index/5)%2?CONFIG.colors.grassDark:CONFIG.colors.grassLight);
        ctx.fillRect(0, p2.y, W, p1.y-p2.y);
        
        // 路面
        ctx.fillStyle = col;
        ctx.beginPath();
        ctx.moveTo(p1.x-p1.w, p1.y); ctx.lineTo(p1.x+p1.w, p1.y);
        ctx.lineTo(p2.x+p2.w, p2.y); ctx.lineTo(p2.x-p2.w, p2.y);
        ctx.fill();
        
        // 路肩
        ctx.fillStyle = '#fff';
        const mw = p1.w * 0.05;
        ctx.fillRect(p1.x-p1.w-mw, p1.y, mw, p1.y-p2.y);
        ctx.fillRect(p1.x+p1.w, p1.y, mw, p1.y-p2.y);
    }

    // 【修改】优化的建筑渲染 - 极简霓虹风格
    function renderBuilding3D(s, b, laneW) {
        const scale = s.p1.screen.scale;
        const screenX = s.p1.screen.x + (scale * b.x * laneW * W / 2);
        const screenY = s.p1.screen.y;
        const buildW = b.w * laneW * scale * W / 2;
        const buildH = b.h * scale * H / 2;
        
        if (buildW < 2 || buildH < 2) return;
        // 简单剔除屏幕外的建筑
        if (screenX + buildW < 0 || screenX - buildW > W) return;

        const palette = PALETTES[Math.floor((b.c || 0) * PALETTES.length) % PALETTES.length];
        
        ctx.save();
        ctx.translate(screenX, screenY);
        
        // 主体：使用线性渐变代替循环画窗户
        const grd = ctx.createLinearGradient(0, -buildH, 0, 0);
        grd.addColorStop(0, palette.light);
        grd.addColorStop(0.3, palette.base);
        grd.addColorStop(1, '#000');
        
        ctx.fillStyle = grd;
        ctx.fillRect(-buildW/2, -buildH, buildW, buildH);
        
        // 霓虹描边
        ctx.strokeStyle = palette.light;
        ctx.lineWidth = 2;
        ctx.strokeRect(-buildW/2, -buildH, buildW, buildH);
        
        // 简单的顶部装饰
        if (b.type === 'tower') {
            ctx.fillStyle = palette.light;
            ctx.fillRect(-2, -buildH-10, 4, 10);
        }
        
        ctx.restore();
    }

    function renderObject(s, lx, laneW, pct, type, obj) {
        const p1 = s.p1.screen, p2 = s.p2.screen;
        const scale = p1.scale + (p2.scale - p1.scale) * pct;
        const sx = p1.x + (p2.x - p1.x) * pct + (scale * lx * laneW * W / 2);
        const sy = p1.y + (p2.y - p1.y) * pct;
        if (type === 'car') {
            const w = 400 * scale * W/2, h = 250 * scale * H/2; // 调整车体比例
            ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(sx-w/2, sy, w, w*0.2); // 阴影
            
            // 简单的车尾形状
            ctx.fillStyle = '#f00'; ctx.fillRect(sx-w/2, sy-h, w, h);
            
            // 尾灯光晕
            ctx.shadowBlur = 10; ctx.shadowColor = '#f00';
            ctx.fillStyle = '#ffaaaa'; 
            ctx.fillRect(sx-w*0.4, sy-h*0.6, w*0.25, h*0.2);
            ctx.fillRect(sx+w*0.15, sy-h*0.6, w*0.25, h*0.2);
            ctx.shadowBlur = 0;
            
        } else {
            const w = 300 * scale * W/2, h = 300 * scale * H/2;
            ctx.fillStyle = '#444'; ctx.fillRect(sx-w/2, sy-h, w, h); // 灰色障碍物
            ctx.strokeStyle = '#ff0'; ctx.lineWidth = 2;
            ctx.strokeRect(sx-w/2, sy-h, w, h);
            ctx.beginPath(); ctx.moveTo(sx-w/2, sy-h); ctx.lineTo(sx+w/2, sy); ctx.stroke();
        }
    }

    // 【修改】第三人称玩家车辆渲染
    function renderPlayer() {
        const carW = 200;
        const carH = 100;
        const x = W/2;
        const y = H - 150; // 位置上移，因为相机高了
        
        ctx.save();
        ctx.translate(x, y);
        
        // 模拟转向时的车身倾斜 (Roll)
        let tilt = 0;
        if(game.keys.left) tilt = -0.05;
        if(game.keys.right) tilt = 0.05;
        ctx.rotate(tilt);
        
        // 车身主体
        ctx.fillStyle = '#111';
        ctx.fillRect(-carW/2, -carH, carW, carH);
        
        // 车顶/后窗
        ctx.fillStyle = '#222';
        ctx.beginPath();
        ctx.moveTo(-carW/2 + 20, -carH);
        ctx.lineTo(carW/2 - 20, -carH);
        ctx.lineTo(carW/2 - 40, -carH - 40);
        ctx.lineTo(-carW/2 + 40, -carH - 40);
        ctx.fill();
        
        // 尾灯 (Bloom Effect)
        const lightW = 40;
        const lightH = 20;
        ctx.shadowBlur = 20;
        ctx.shadowColor = '#f00';
        ctx.fillStyle = '#f00';
        // 左尾灯
        ctx.fillRect(-carW/2 + 10, -carH + 20, lightW, lightH);
        // 右尾灯
        ctx.fillRect(carW/2 - 10 - lightW, -carH + 20, lightW, lightH);
        
        // 刹车灯效果 (简单模拟减速)
        // (此处略，保持简洁)

        // 喷气尾焰 (加速时)
        if(game.player.speed > 5000) {
             ctx.shadowColor = '#0ff';
             ctx.fillStyle = '#0ff';
             const h = (game.player.speed / CONFIG.maxSpeed) * 60;
             ctx.globalAlpha = 0.6;
             ctx.fillRect(-20, -10, 10, h);
             ctx.fillRect(10, -10, 10, h);
        }

        ctx.restore();
    }

    function initAudio() {
        const AC = window.AudioContext || window.webkitAudioContext;
        game.audio = new AC();
        const osc = game.audio.createOscillator();
        const gain = game.audio.createGain();
        osc.type = 'sawtooth'; osc.frequency.value=50; gain.gain.value=0.1;
        osc.connect(gain); gain.connect(game.audio.destination); osc.start();
        setInterval(()=>{
            const freq = 50 + (game.player.speed/CONFIG.maxSpeed)*200;
            osc.frequency.setTargetAtTime(freq, game.audio.currentTime, 0.1);
            gain.gain.value = (game.state===STATE.MENU)?0:0.1;
        }, 100);
    }
    function playExplosionSound(intensity=1){
        try{
            if(!game.audio) return;
            const ctxA = game.audio;
            const buffer = ctxA.createBuffer(1, ctxA.sampleRate*0.25, ctxA.sampleRate);
            const data = buffer.getChannelData(0);
            for(let i=0;i<data.length;i++){
                const t = i/data.length;
                data[i] = (Math.random()*2-1)*Math.pow(1-t,2.4)*intensity;
            }
            const src = ctxA.createBufferSource(); src.buffer=buffer;
            const gain = ctxA.createGain(); gain.gain.value=0.6*intensity;
            const bp = ctxA.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=180+intensity*180;
            src.connect(bp).connect(gain).connect(ctxA.destination);
            src.start();
        }catch(e){}
    }
    init();
</script>
</body>
</html>