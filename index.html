<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>CYBER RUSH: ARCHITECT (极速冲锋：建筑师版)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        body { margin: 0; overflow: hidden; background: #050510; color: #fff; font-family: 'Orbitron', sans-serif; user-select: none; }
        #game-container { position: relative; width: 100vw; height: 100vh; overflow: hidden;}
        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }

        /* UI 层 */
        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #hud-top { display: flex; justify-content: space-between; padding: 30px; font-weight: 900; letter-spacing: 2px; text-shadow: 0 0 10px #0ff; }
        .stat-value { font-size: 40px; color: #fff; text-shadow: 2px 2px 0 #f0f; }

        #speed-container { position: absolute; top: 10%; left: 50%; transform: translateX(-50%) skew(-10deg); text-align: center; }
        #speed-val { font-size: 100px; line-height: 80px; font-weight: 900; background: linear-gradient(to bottom, #fff, #888); -webkit-background-clip: text; -webkit-text-fill-color: transparent; filter: drop-shadow(0 0 15px #0ff); }
        #speed-unit { font-size: 24px; color: #0ff; letter-spacing: 5px; }

        #rage-container { position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%); width: 600px; height: 40px; border: 4px solid #fff; transform: skew(-20deg); box-shadow: 0 0 30px #f00; background: rgba(0,0,0,0.5); }
        #rage-fill { width: 0%; height: 100%; background: repeating-linear-gradient(45deg, #f00, #f00 10px, #900 10px, #900 20px); transition: width 0.05s linear; }

        #center-msg { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); text-align: center; white-space: nowrap; z-index: 10; display: none; text-shadow: 0 0 20px #f00;}
        .msg-big { font-size: 120px; font-weight: 900; color: #fff; -webkit-text-stroke: 4px #000; }
        .msg-sub { font-size: 40px; color: #0ff; background: #000; padding: 5px 20px; }

        /* 菜单样式 */
        #menu-layer { background: rgba(0,0,0,0.85); backdrop-filter: blur(10px); display: flex; flex-direction: column; justify-content: center; align-items: center; pointer-events: auto; }
        .glitch-title { font-size: 80px; font-weight: 900; color: #fff; text-shadow: 4px 0 #f00, -4px 0 #0ff; margin-bottom: 20px; }

        .menu-view { display: flex; flex-direction: column; align-items: center; width: 100%; transition: opacity 0.3s; }

        .settings-box { background: rgba(0,20,40,0.9); border: 1px solid #0ff; padding: 30px; margin-bottom: 20px; width: 600px; text-align: left; box-shadow: 0 0 30px rgba(0,255,255,0.1); border-radius: 4px; }
        .setting-item { margin-bottom: 25px; }
        .setting-label { color: #fff; font-size: 18px; display:flex; justify-content:space-between; margin-bottom: 8px; font-weight: 700;}
        input[type=range] { width: 100%; height: 6px; background: #333; outline: none; -webkit-appearance: none; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; background: #0ff; cursor: pointer; border: 2px solid #fff; box-shadow: 0 0 10px #0ff; }

        button { background: #000; border: 2px solid #0ff; color: #0ff; padding: 15px 40px; margin: 10px; font-size: 24px; font-family: 'Orbitron'; cursor: pointer; text-transform: uppercase; transition: 0.2s; position: relative; overflow: hidden; width: 400px; }
        button:hover { background: #0ff; color: #000; box-shadow: 0 0 30px #0ff; }
    </style>
</head>
<body>
<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div id="warp-overlay"></div>

    <div id="hud" class="ui-layer" style="display: none;">
        <div id="hud-top">
            <div class="stat-group"><div class="stat-label">SCORE</div><div id="score-val" class="stat-value">0</div></div>
            <div class="stat-group" style="align-items: flex-end;"><div class="stat-label">KILLS</div><div id="kill-val" class="stat-value" style="color:#f33">0</div></div>
        </div>
        <div id="speed-container">
            <div id="speed-val">0</div>
            <div id="speed-unit">KM/H</div>
        </div>
        <div id="center-msg"></div>
        <div id="rage-container"><div id="rage-fill"></div></div>
    </div>

    <div id="menu-layer" class="ui-layer">
        <div class="glitch-title">CYBER RUSH</div>

        <div id="view-main" class="menu-view">
            <button onclick="startGame()">启动引擎</button>
            <button onclick="switchView('settings')">系统设置</button>
        </div>

        <div id="view-settings" class="menu-view" style="display: none;">
            <div class="settings-box">
                <h3 style="color: #0ff; border-bottom: 1px solid #444; padding-bottom: 10px; margin-top: 0;">地图构造参数</h3>

                <!-- 1. 建筑密度 (新增) -->
                <div class="setting-item">
                    <label class="setting-label">建筑密度 <span id="val-den" style="color:#0f0">中等</span></label>
                    <input type="range" id="set-den" min="0" max="10" value="5">
                    <div style="font-size:12px; color:#666; margin-top:5px;">控制城市建筑的密集程度，变更后需重启游戏生效</div>
                </div>

                <!-- 2. 道路宽度 -->
                <div class="setting-item">
                    <label class="setting-label">道路宽度 <span id="val-road" style="color:#0f0">100%</span></label>
                    <input type="range" id="set-road" min="50" max="150" value="100">
                </div>

                <h3 style="color: #f0f; border-bottom: 1px solid #444; padding-bottom: 10px; margin-top: 30px;">游戏参数</h3>
                <div class="setting-item">
                    <label class="setting-label">车流密度 <span id="val-traf" style="color:#f0f">2%</span></label>
                    <input type="range" id="set-traf" min="0" max="10" value="2">
                </div>
                <div class="setting-item">
                    <label class="setting-label">车流速度 <span id="val-spd" style="color:#ff0">正常</span></label>
                    <input type="range" id="set-spd" min="1" max="5" value="2">
                </div>
            </div>
            <button onclick="applySettings()">应用并重启</button>
            <button onclick="switchView('main')" style="border-color:#666; color:#888;">返回</button>
        </div>
    </div>
</div>


<script>
    // --- 核心常量 ---
    const CONFIG = {
        segL: 200,
        laneW: 2400,        // 逻辑车道归一化基准
        roadW: 2200,        // 实际路面宽度
        camH: 3500,
        camD: 0.95,
        drawDist: 500,
        accel: 80,
        maxSpeed: 12000,
        rushSpeed: 120000,
        rageDrain: 5,
        colors: {
            sky: '#050510',
            roadDark: '#101015', roadLight: '#181820',
            grassDark: '#020205', grassLight: '#040408'
        }
    };

    // --- 玩家设置 ---
    const SETTINGS = {
        roadWidthScale: 1.0,
        buildDensity: 0.5,
        carDensity: 0.02,
        carSpeedMult: 1.0
    };

    const STATE = { MENU: 0, PLAY: 1, RUSH: 2 };

    // 霓虹配色表
    const PALETTES = [
        { base: '#1a0033', light: '#d0f' },
        { base: '#001a33', light: '#0ff' },
        { base: '#331a00', light: '#fa0' },
        { base: '#00331a', light: '#0f6' },
        { base: '#222',    light: '#fff' }
    ];

    let game = {
        state: STATE.MENU,
        time: 0, dt: 0,
        segments: [], cars: [], particles: [],
        player: { x: 0, z: 0, speed: 0, score: 0, rage: 0, kills: 0 },
        keys: { left: false, right: false },
        cam: { shake: 0 },
        audio: null
    };

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    let W, H;

    function init() {
        resize();
        window.addEventListener('resize', resize);
        window.addEventListener('keydown', e => {
            if(e.key === 'ArrowLeft' || e.key === 'a') game.keys.left = true;
            if(e.key === 'ArrowRight' || e.key === 'd') game.keys.right = true;
        });
        window.addEventListener('keyup', e => {
            if(e.key === 'ArrowLeft' || e.key === 'a') game.keys.left = false;
            if(e.key === 'ArrowRight' || e.key === 'd') game.keys.right = false;
        });
        bindUI();
    }

    function bindUI() {
        const denInput = document.getElementById('set-den');
        denInput.oninput = function() {
            SETTINGS.buildDensity = this.value / 10;
            let txt = "稀疏";
            if(this.value > 3) txt = "中等";
            if(this.value > 7) txt = "密集";
            if(this.value == 10) txt = "极度拥挤";
            document.getElementById('val-den').innerText = txt;
        };

        const roadInput = document.getElementById('set-road');
        roadInput.oninput = function() {
            SETTINGS.roadWidthScale = this.value / 100;
            document.getElementById('val-road').innerText = this.value + "%";
        };

        const trafInput = document.getElementById('set-traf');
        trafInput.oninput = function() {
            SETTINGS.carDensity = this.value / 100;
            document.getElementById('val-traf').innerText = this.value + "%";
        };

        const spdInput = document.getElementById('set-spd');
        spdInput.oninput = function() {
            const val = parseInt(this.value);
            SETTINGS.carSpeedMult = [0.5, 1.0, 1.5, 2.0, 3.0][val - 1];
            document.getElementById('val-spd').innerText = ["缓慢", "正常", "快速", "极速", "光速"][val - 1];
        };
    }

    function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }

    function switchView(name) {
        document.getElementById('view-main').style.display = name === 'main' ? 'flex' : 'none';
        document.getElementById('view-settings').style.display = name === 'settings' ? 'flex' : 'none';
    }

    function applySettings() {
        startGame();
    }

    function startGame() {
        if (!game.audio) initAudio();
        game.segments = [];
        game.cars = [];
        game.particles = [];
        game.player = { x: 0, z: 0, speed: 0, score: 0, rage: 0, kills: 0 };
        game.state = STATE.PLAY;

        generateTrack();

        document.getElementById('menu-layer').style.display = 'none';
        document.getElementById('hud').style.display = 'block';
        document.getElementById('game-container').classList.remove('rush-active');
        showMsg("系统就绪", "RACE START", 2000);
        gameLoop(0);
    }

    function generateTrack() {
        const totalSegs = 3000;
        const roadEdgeNorm = (CONFIG.roadW / CONFIG.laneW);
        let buildAccumulator = 0;

        for (let i = 0; i < totalSegs; i++) {
            const curve = (Math.floor(i/100)%2) ? Math.sin(i/20) * 4 : 0;
            const y = Math.sin(i/40) * 1000;
            const buildings = [];

            buildAccumulator += SETTINGS.buildDensity;

            if (buildAccumulator > 1.0 + Math.random()) {
                buildAccumulator = 0;
                const wLeft = 1.0 + Math.random() * 2.5;
                const wRight = 1.0 + Math.random() * 2.5;
                const buffer = 0.15;

                const xLeft = -(roadEdgeNorm + buffer + wLeft/2);
                const xRight = (roadEdgeNorm + buffer + wRight/2);

                buildings.push({ x: xLeft, w: wLeft, h: 4000 + Math.random() * 8000, c: Math.random() });
                buildings.push({ x: xRight, w: wRight, h: 4000 + Math.random() * 8000, c: Math.random() });
            }

            const sprites = [];
            if (i > 50 && Math.random() < 0.03) {
                const safeZone = roadEdgeNorm * 0.8;
                sprites.push({ type: 'block', x: (Math.random()*2 - 1) * safeZone });
            }

            if (i > 50 && Math.random() < SETTINGS.carDensity) {
                let speed = (3000 + Math.random()*2000) * SETTINGS.carSpeedMult;
                const safeZone = roadEdgeNorm * 0.8;
                game.cars.push({ z: i * CONFIG.segL, x: (Math.random()*2-1)*safeZone, speed: speed, active: true });
            }

            game.segments.push({
                index: i,
                p1: { world: { y: y, z: i*CONFIG.segL }, camera: {}, screen: {} },
                p2: { world: { y: y, z: (i+1)*CONFIG.segL }, camera: {}, screen: {} },
                curve: curve,
                sprites: sprites,
                buildings: buildings,
                color: Math.floor(i/5)%2 ? CONFIG.colors.roadDark : CONFIG.colors.roadLight
            });
        }
    }

    let lastTime = 0;
    function gameLoop(time) {
        if (game.state === STATE.MENU) return;
        const dt = Math.min(0.1, (time - lastTime) / 1000);
        lastTime = time;
        update(dt);
        render();
        requestAnimationFrame(gameLoop);
    }

    function update(dt) {
        const p = game.player;
        const maxS = (game.state === STATE.RUSH) ? CONFIG.rushSpeed : CONFIG.maxSpeed;

        p.speed += CONFIG.accel * (game.state === STATE.RUSH ? 10 : 1);
        if (p.speed > maxS) p.speed = maxS;
        p.z += p.speed * dt;

        let speedRatio = (p.speed / CONFIG.maxSpeed);
        let dx = dt * (2.0 * speedRatio + 0.5);
        if (game.state === STATE.RUSH) dx *= 1.5;

        if (game.keys.left) p.x -= dx;
        if (game.keys.right) p.x += dx;

        const currentSeg = game.segments[Math.floor(p.z/CONFIG.segL) % game.segments.length];
        p.x -= (dx * speedRatio * currentSeg.curve * 0.8);

        const currentRoadLimit = (CONFIG.roadW / CONFIG.laneW) * SETTINGS.roadWidthScale - 0.1;
        if (p.x < -currentRoadLimit) { p.x = -currentRoadLimit; if(p.speed>8000) p.speed-=100; }
        if (p.x > currentRoadLimit) { p.x = currentRoadLimit; if(p.speed>8000) p.speed-=100; }

        game.cars.forEach(car => {
            car.z += car.speed * dt;
            if (Math.abs(car.z - p.z) < 300 && Math.abs(car.x - p.x) < 0.7) handleCollision(car, 'car');
        });
        currentSeg.sprites.forEach((s, i) => {
            if (Math.abs(p.x - s.x) < 0.7) { handleCollision(s, 'obs'); currentSeg.sprites.splice(i, 1); }
        });

        if (game.state === STATE.RUSH) {
            p.rage -= dt * 20;
            p.score += 2000 * dt;
            if (p.rage <= 0) exitRushMode();
        } else {
            p.rage = Math.max(0, p.rage - dt * CONFIG.rageDrain);
            if (p.rage >= 100) enterRushMode();
        }

        if (game.cam.shake > 0) game.cam.shake = Math.max(0, game.cam.shake - dt*100);
        updateUI();
        updateParticles(dt);
    }

    function handleCollision(target, type) {
        const p = game.player;
        const isRush = game.state === STATE.RUSH;
        game.cam.shake = isRush ? 15 : 30;
        spawnExplosion(W/2, H/2+50, 30, isRush ? '#0ff' : '#f90');

        if (isRush) {
            if (type === 'car') { target.active = false; target.z = -5000; }
            p.score += 5000; p.kills++; showMsg("DESTROYED", "+5000");
        } else {
            p.speed *= 0.6;
            game.player.rage += CONFIG.ragePerHit;
            showMsg("IMPACT", "SPEED LOST");
        }
    }

    function enterRushMode() {
        game.state = STATE.RUSH;
        document.getElementById('game-container').classList.add('rush-active');
        document.getElementById('rage-container').classList.add('full');
        showMsg("HYPER DRIVE", "ENGAGED");
    }
    function exitRushMode() {
        game.state = STATE.PLAY;
        game.player.rage = 0;
        document.getElementById('game-container').classList.remove('rush-active');
        document.getElementById('rage-container').classList.remove('full');
    }

    function updateParticles(dt) {
        for(let i=game.particles.length-1; i>=0; i--) {
            let pt = game.particles[i];
            pt.x += pt.vx; pt.y += pt.vy; pt.life -= dt; pt.vy += 5*dt;
            if(pt.life <= 0) game.particles.splice(i,1);
        }
    }

    // --- 补全的函数 ---
    function renderParticles() {
        game.particles.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life;
            ctx.fillRect(p.x, p.y, p.size, p.size);
        });
        ctx.globalAlpha = 1;
    }

    function spawnExplosion(x,y,n,c) {
        for(let i=0;i<n;i++) {
            const a = Math.random()*6.28, s = Math.random()*15+5;
            game.particles.push({x:x,y:y,vx:Math.cos(a)*s,vy:Math.sin(a)*s,life:Math.random(),color:c,size:Math.random()*6+2});
        }
    }
    function updateUI() {
        document.getElementById('score-val').innerText = Math.floor(game.player.score);
        document.getElementById('speed-val').innerText = Math.floor(game.player.speed/100);
        document.getElementById('kill-val').innerText = game.player.kills;
        document.getElementById('rage-fill').style.width = game.player.rage + '%';
    }
    function showMsg(m,s,t=1000) {
        const el = document.getElementById('center-msg');
        el.innerHTML = `<div class="msg-big">${m}</div><div class="msg-sub">${s}</div>`;
        el.style.display = 'block';
        clearTimeout(game.msgTimer);
        game.msgTimer = setTimeout(()=>el.style.display='none', t);
    }

    function render() {
        ctx.fillStyle = game.state === STATE.RUSH ? '#100' : CONFIG.colors.sky;
        ctx.fillRect(0,0,W,H);

        let sx = (Math.random()-0.5)*game.cam.shake, sy = (Math.random()-0.5)*game.cam.shake;
        ctx.save(); ctx.translate(sx, sy);

        const baseIdx = Math.floor(game.player.z/CONFIG.segL);
        let maxY = H;

        for(let n=0; n<CONFIG.drawDist; n++) {
            const segment = game.segments[(baseIdx + n) % game.segments.length];
            const loopedIdx = (segment.index < baseIdx) ? segment.index + game.segments.length : segment.index;
            const offsetZ = (loopedIdx * CONFIG.segL) - game.player.z;

            if(offsetZ < CONFIG.camD) continue;

            const currentLaneW = CONFIG.laneW * SETTINGS.roadWidthScale;
            project(segment.p1, game.player.x * currentLaneW, offsetZ);
            project(segment.p2, game.player.x * currentLaneW - (segment.curve * (offsetZ/CONFIG.segL)), offsetZ+CONFIG.segL);

            if(segment.p1.screen.y >= maxY) continue;

            renderRoad(segment);
            maxY = segment.p1.screen.y;
        }

        for(let n=CONFIG.drawDist-1; n>0; n--) {
            const segment = game.segments[(baseIdx + n) % game.segments.length];
            const currentLaneW = CONFIG.laneW * SETTINGS.roadWidthScale;

            segment.buildings.forEach(b => renderBuilding3D(segment, b, currentLaneW));

            game.cars.forEach(car => {
                if(car.z >= segment.p1.world.z && car.z < segment.p2.world.z) {
                    const pct = (car.z - segment.p1.world.z) / CONFIG.segL;
                    renderObject(segment, car.x, currentLaneW, pct, 'car', car);
                }
            });
            segment.sprites.forEach(s => renderObject(segment, s.x, currentLaneW, 0, 'block'));
        }

        renderPlayer();
        renderParticles();
        ctx.restore();
    }

    function project(p, cx, cz) {
        p.camera.x = p.world.x || 0;
        p.camera.y = (p.world.y || 0) - CONFIG.camH;
        p.camera.z = cz;
        p.screen.scale = CONFIG.camD / cz;
        p.screen.x = Math.round((W/2) + (p.screen.scale * (-cx) * W/2));
        p.screen.y = Math.round((H*0.45) - (p.screen.scale * p.camera.y * H/2));
        p.screen.w = Math.round(p.screen.scale * CONFIG.roadW * SETTINGS.roadWidthScale * W/2);
    }

    function renderRoad(s) {
        const p1=s.p1.screen, p2=s.p2.screen;
        const col = game.state===STATE.RUSH ? (Math.floor(s.index/2)%2?'#f0f':'#0ff') : s.color;

        ctx.fillStyle = game.state===STATE.RUSH?'#000':(Math.floor(s.index/5)%2?CONFIG.colors.grassDark:CONFIG.colors.grassLight);
        ctx.fillRect(0, p2.y, W, p1.y-p2.y);

        ctx.fillStyle = col;
        ctx.beginPath();
        ctx.moveTo(p1.x-p1.w, p1.y); ctx.lineTo(p1.x+p1.w, p1.y);
        ctx.lineTo(p2.x+p2.w, p2.y); ctx.lineTo(p2.x-p2.w, p2.y);
        ctx.fill();

        ctx.fillStyle = '#fff';
        const mw = p1.w * 0.05;
        ctx.fillRect(p1.x-p1.w-mw, p1.y, mw, p1.y-p2.y);
        ctx.fillRect(p1.x+p1.w, p1.y, mw, p1.y-p2.y);
    }

    function renderBuilding3D(s, b, laneW) {
        const scale = s.p1.screen.scale;
        const screenX = s.p1.screen.x + (scale * b.x * laneW * W / 2);
        const screenY = s.p1.screen.y;

        const buildW = b.w * laneW * scale * W / 2;
        const buildH = b.h * scale * H / 2;

        if (screenX - buildW < -W || screenX + buildW > W*2) return;

        const palette = PALETTES[Math.floor(b.c * PALETTES.length) % PALETTES.length];
        const style = Math.floor(b.c * 100) % 3;

        const frontW = buildW;
        const frontH = buildH;

        let frontX = screenX - frontW / 2;
        let frontY = screenY - frontH;

        const sideW = Math.abs(b.x) * (frontW * 0.5);

        let sideDrawX, sideDrawW;
        if (b.x < 0) {
            sideDrawX = frontX + frontW;
            sideDrawW = sideW;
        } else {
            sideDrawX = frontX - sideW;
            sideDrawW = sideW;
        }

        ctx.fillStyle = '#000';
        const sideGrad = ctx.createLinearGradient(0, frontY, 0, frontY + frontH);
        sideGrad.addColorStop(0, '#111');
        sideGrad.addColorStop(1, '#000');
        ctx.fillStyle = sideGrad;
        ctx.fillRect(sideDrawX, frontY, sideDrawW, frontH);

        drawFaceDetails(sideDrawX, frontY, sideDrawW, frontH, palette.light, style, b.c, true);

        const frontGrad = ctx.createLinearGradient(0, frontY, 0, frontY + frontH);
        frontGrad.addColorStop(0, palette.light);
        frontGrad.addColorStop(0.4, palette.base);
        frontGrad.addColorStop(1, '#000');

        ctx.fillStyle = frontGrad;
        ctx.fillRect(frontX, frontY, frontW, frontH);

        drawFaceDetails(frontX, frontY, frontW, frontH, palette.light, style, b.c, false);

        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.moveTo(frontX, frontY);
        ctx.lineTo(frontX + frontW, frontY);
        if (b.x < 0) {
            ctx.lineTo(sideDrawX + sideDrawW, frontY);
            ctx.lineTo(sideDrawX, frontY);
        } else {
            ctx.lineTo(frontX, frontY);
            ctx.lineTo(sideDrawX, frontY);
            ctx.lineTo(sideDrawX + sideDrawW, frontY);
        }
        ctx.fill();

        if (scale > 0.001) {
            ctx.strokeStyle = palette.light;
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.3;
            ctx.strokeRect(frontX, frontY, frontW, frontH);
            ctx.globalAlpha = 1;
        }
    }

    function drawFaceDetails(x, y, w, h, color, style, seed, isSide) {
        if (w < 5 || h < 10) return;

        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.fillStyle = color;

        ctx.globalAlpha = isSide ? 0.3 : 0.6;

        if (style === 0) {
            const floorH = h / 15;
            for(let i=1; i<15; i+=2) {
                if (Math.sin(seed * i + (isSide?1:0)) > -0.2) {
                    ctx.fillRect(x + 2, y + i*floorH, w - 4, floorH * 0.5);
                }
            }
        } else if (style === 1) {
            const cols = isSide ? Math.max(1, Math.floor(w/15)) : 3;
            const rows = 10;
            const cw = w / cols, ch = h / rows;
            for(let r=0; r<rows; r++) {
                for(let c=0; c<cols; c++) {
                    if (Math.sin(seed * r * c * 9) > 0.3) {
                        ctx.fillRect(x + c*cw + 2, y + r*ch + 2, cw - 4, ch - 4);
                    }
                }
            }
        } else {
            if (!isSide) {
                ctx.globalAlpha = 0.2;
                ctx.fillRect(x + w*0.8, y, w*0.1, h);
            }
        }
        ctx.restore();
    }

    function renderObject(s, lx, laneW, pct, type, obj) {
        const p1 = s.p1.screen, p2 = s.p2.screen;
        const scale = p1.scale + (p2.scale - p1.scale) * pct;
        const sx = p1.x + (p2.x - p1.x) * pct + (scale * lx * laneW * W / 2);
        const sy = p1.y + (p2.y - p1.y) * pct;

        if (type === 'car') {
            const w = 400 * scale * W/2, h = 300 * scale * H/2;
            ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(sx-w/2, sy, w, w*0.2);
            ctx.fillStyle = '#f00'; ctx.fillRect(sx-w/2, sy-h, w, h);
            ctx.fillStyle = '#500'; ctx.fillRect(sx-w/2, sy-h, w, h*0.2);
            ctx.fillStyle = '#f00'; ctx.shadowBlur=10; ctx.shadowColor='#f00';
            ctx.fillRect(sx-w*0.4, sy-h*0.4, w*0.3, h*0.15);
            ctx.fillRect(sx+w*0.1, sy-h*0.4, w*0.3, h*0.15);
            ctx.shadowBlur=0;
        } else {
            const w = 300 * scale * W/2, h = 300 * scale * H/2;
            ctx.fillStyle = '#888'; ctx.fillRect(sx-w/2, sy-h, w, h);
            ctx.fillStyle = '#ff0';
            ctx.beginPath(); ctx.moveTo(sx-w/2, sy-h); ctx.lineTo(sx+w/2, sy); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(sx, sy-h); ctx.lineTo(sx+w/2, sy-h/2); ctx.stroke();
        }
    }

    function renderPlayer() {
        const x=W/2, y=H-80, w=120, h=60;
        const bounce = Math.sin(Date.now()/50)*2;
        ctx.save(); ctx.translate(x, y+bounce);
        if(game.keys.left) ctx.rotate(-0.05); if(game.keys.right) ctx.rotate(0.05);

        if(game.state === STATE.RUSH) {
            ctx.fillStyle = 'rgba(0,255,255,0.2)';
            ctx.fillRect(-w/2-20, -h, w+40, h);
        }

        ctx.fillStyle = '#000'; ctx.strokeStyle = game.state === STATE.RUSH ? '#fff' : '#0ff'; ctx.lineWidth = 4;
        ctx.beginPath(); ctx.moveTo(-w/2, 0); ctx.lineTo(-w/2+10, -h); ctx.lineTo(w/2-10, -h); ctx.lineTo(w/2, 0);
        ctx.fill(); ctx.stroke();

        const fl = (game.player.speed/CONFIG.maxSpeed)*50 + (game.state===STATE.RUSH?120:0);
        ctx.fillStyle = game.state===STATE.RUSH?'#0ff':(Math.random()>0.5?'#f00':'#ff0');
        ctx.shadowBlur=20; ctx.shadowColor=ctx.fillStyle;
        ctx.beginPath(); ctx.moveTo(-30,0); ctx.lineTo(-20,fl); ctx.lineTo(-10,0);
        ctx.moveTo(10,0); ctx.lineTo(20,fl); ctx.lineTo(30,0); ctx.fill();
        ctx.shadowBlur=0;
        ctx.restore();
    }

    function initAudio() {
        const AC = window.AudioContext || window.webkitAudioContext;
        game.audio = new AC();
        const osc = game.audio.createOscillator();
        const gain = game.audio.createGain();
        osc.type = 'sawtooth'; osc.frequency.value=50; gain.gain.value=0.1;
        osc.connect(gain); gain.connect(game.audio.destination); osc.start();
        setInterval(()=>{
            const freq = 50 + (game.player.speed/CONFIG.maxSpeed)*200;
            osc.frequency.setTargetAtTime(freq, game.audio.currentTime, 0.1);
            gain.gain.value = (game.state===STATE.MENU)?0:0.1;
        }, 100);
    }

    init();
</script>


</body>
</html>