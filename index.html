<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>CYBER RUSH: ARCHITECT（失控赛车：不刹车）</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        body { margin: 0; overflow: hidden; background: #050510; color: #fff; font-family: 'Orbitron', sans-serif; user-select: none; }
        #game-container { position: relative; width: 100vw; height: 100vh; overflow: hidden;}
        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }

        /* UI 层 */
        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #hud-top { display: flex; justify-content: space-between; padding: 30px; font-weight: 900; letter-spacing: 2px; text-shadow: 0 0 10px #0ff; }
        .stat-value { font-size: 40px; color: #fff; text-shadow: 2px 2px 0 #f0f; }

        #speed-container { position: absolute; top: 10%; left: 50%; transform: translateX(-50%) skew(-10deg); text-align: center; }
        #speed-val { font-size: 100px; line-height: 80px; font-weight: 900; background: linear-gradient(to bottom, #fff, #888); -webkit-background-clip: text; -webkit-text-fill-color: transparent; filter: drop-shadow(0 0 15px #0ff); }
        #speed-unit { font-size: 24px; color: #0ff; letter-spacing: 5px; }

        #rage-container { position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%); width: 600px; height: 40px; border: 4px solid #fff; transform: skew(-20deg); box-shadow: 0 0 30px #f00; background: rgba(0,0,0,0.5); }
        #rage-fill { width: 0%; height: 100%; background: repeating-linear-gradient(45deg, #f00, #f00 10px, #900 10px, #900 20px); transition: width 0.05s linear; }

        #center-msg { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); text-align: center; white-space: nowrap; z-index: 10; display: none; text-shadow: 0 0 20px #f00;}
        .msg-big { font-size: 120px; font-weight: 900; color: #fff; -webkit-text-stroke: 4px #000; }
        .msg-sub { font-size: 40px; color: #0ff; background: #000; padding: 5px 20px; }

        /* 菜单样式 */
        #menu-layer { background: rgba(0,0,0,0.85); backdrop-filter: blur(10px); display: flex; flex-direction: column; justify-content: center; align-items: center; pointer-events: auto; }
        .glitch-title { font-size: 80px; font-weight: 900; color: #fff; text-shadow: 4px 0 #f00, -4px 0 #0ff; margin-bottom: 20px; }

        .menu-view { display: flex; flex-direction: column; align-items: center; width: 100%; transition: opacity 0.3s; }

        .settings-box { background: rgba(0,20,40,0.9); border: 1px solid #0ff; padding: 30px; margin-bottom: 20px; width: 600px; text-align: left; box-shadow: 0 0 30px rgba(0,255,255,0.1); border-radius: 4px; }
        .setting-item { margin-bottom: 25px; }
        .setting-label { color: #fff; font-size: 18px; display:flex; justify-content:space-between; margin-bottom: 8px; font-weight: 700;}
        input[type=range] { width: 100%; height: 6px; background: #333; outline: none; -webkit-appearance: none; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; background: #0ff; cursor: pointer; border: 2px solid #fff; box-shadow: 0 0 10px #0ff; }

        button { background: #000; border: 2px solid #0ff; color: #0ff; padding: 15px 40px; margin: 10px; font-size: 24px; font-family: 'Orbitron'; cursor: pointer; text-transform: uppercase; transition: 0.2s; position: relative; overflow: hidden; width: 400px; }
        button:hover { background: #0ff; color: #000; box-shadow: 0 0 30px #0ff; }
    </style>
</head>
<body>
<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div id="warp-overlay"></div>

    <div id="hud" class="ui-layer" style="display: none;">
        <div id="hud-top">
            <div class="stat-group"><div class="stat-label">SCORE</div><div id="score-val" class="stat-value">0</div></div>
            <div class="stat-group" style="align-items: flex-end;"><div class="stat-label">KILLS</div><div id="kill-val" class="stat-value" style="color:#f33">0</div></div>
        </div>
        <div id="speed-container">
            <div id="speed-val">0</div>
            <div id="speed-unit">KM/H</div>
        </div>
        <div id="center-msg"></div>
        <div id="rage-container"><div id="rage-fill"></div></div>
    </div>

    <div id="menu-layer" class="ui-layer">
        <div class="glitch-title">CYBER RUSH</div>

        <div id="view-main" class="menu-view">
            <button onclick="startGame()">启动引擎</button>
            <button onclick="switchView('settings')">系统设置</button>
        </div>

        <div id="view-settings" class="menu-view" style="display: none;">
            <div class="settings-box">
                <h3 style="color: #0ff; border-bottom: 1px solid #444; padding-bottom: 10px; margin-top: 0;">赛道生成参数</h3>

                <!-- 1. 建筑密度 -->
                <div class="setting-item">
                    <label class="setting-label">建筑密度 <span id="val-den" style="color:#0f0">中等</span></label>
                    <input type="range" id="set-den" min="0" max="10" value="5">
                    <div style="font-size:12px; color:#666; margin-top:5px;">控制城市建筑的稠密程度，修改后需重启游戏生效</div>
                </div>

                <!-- 2. 赛道宽度 -->
                <div class="setting-item">
                    <label class="setting-label">赛道宽度 <span id="val-road" style="color:#0f0">100%</span></label>
                    <input type="range" id="set-road" min="50" max="150" value="100">
                </div>

                <h3 style="color: #f0f; border-bottom: 1px solid #444; padding-bottom: 10px; margin-top: 30px;">游戏参数</h3>
                <div class="setting-item">
                    <label class="setting-label">车流密度 <span id="val-traf" style="color:#f0f">2%</span></label>
                    <input type="range" id="set-traf" min="0" max="10" value="2">
                </div>
                <div class="setting-item">
                    <label class="setting-label">车流速度 <span id="val-spd" style="color:#ff0">正常</span></label>
                    <input type="range" id="set-spd" min="1" max="5" value="2">
                </div>
            </div>
            <button onclick="applySettings()">应用并重启</button>
            <button onclick="switchView('main')" style="border-color:#666; color:#888;">返回</button>
        </div>
    </div>
</div>


<script>
    // --- 基础常量 ---
    const CONFIG = {
        segL: 200,
        laneW: 2400,        // 视角单位宽度
        roadW: 2200,        // 实际路面宽度
        camH: 3500,
        camD: 0.95,
        drawDist: 500,
        accel: 80,
        maxSpeed: 12000,
        rushSpeed: 120000,
        rageDrain: 5,
        ragePerHit: 8,
        colors: {
            sky: '#050510',
            roadDark: '#101015', roadLight: '#181820',
            grassDark: '#020205', grassLight: '#040408'
        }
    };

    const SETTINGS = {
        roadWidthScale: 1.0,
        buildDensity: 0.5,
        carDensity: 0.02,
        carSpeedMult: 1.0
    };

    const STATE = { MENU: 0, PLAY: 1, RUSH: 2 };

    const PALETTES = [
        { base: '#1a0033', light: '#d0f' },
        { base: '#001a33', light: '#0ff' },
        { base: '#331a00', light: '#fa0' },
        { base: '#00331a', light: '#0f6' },
        { base: '#222',    light: '#fff' }
    ];

    let game = {
        state: STATE.MENU,
        time: 0, dt: 0,
        segments: [], cars: [], particles: [],
        player: { x: 0, z: 0, speed: 0, score: 0, rage: 0, kills: 0 },
        keys: { left: false, right: false },
        cam: { shake: 0 },
        audio: null
    };
    let speedTier = 0;

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    let W, H;

    function init() {
        resize();
        window.addEventListener('resize', resize);
        window.addEventListener('keydown', e => {
            if(e.key === 'ArrowLeft' || e.key === 'a') game.keys.left = true;
            if(e.key === 'ArrowRight' || e.key === 'd') game.keys.right = true;
        });
        window.addEventListener('keyup', e => {
            if(e.key === 'ArrowLeft' || e.key === 'a') game.keys.left = false;
            if(e.key === 'ArrowRight' || e.key === 'd') game.keys.right = false;
        });
        bindUI();
    }

    function bindUI() {
        const denInput = document.getElementById('set-den');
        denInput.oninput = function() {
            SETTINGS.buildDensity = this.value / 10;
            let txt = "稀疏";
            if(this.value > 3) txt = "中等";
            if(this.value > 7) txt = "密集";
            if(this.value == 10) txt = "摩天林立";
            document.getElementById('val-den').innerText = txt;
        };

        const roadInput = document.getElementById('set-road');
        roadInput.oninput = function() {
            SETTINGS.roadWidthScale = this.value / 100;
            document.getElementById('val-road').innerText = this.value + "%";
        };

        const trafInput = document.getElementById('set-traf');
        trafInput.oninput = function() {
            SETTINGS.carDensity = this.value / 100;
            document.getElementById('val-traf').innerText = this.value + "%";
        };

        const spdInput = document.getElementById('set-spd');
        spdInput.oninput = function() {
            const val = parseInt(this.value);
            SETTINGS.carSpeedMult = [0.5, 1.0, 1.5, 2.0, 3.0][val - 1];
            document.getElementById('val-spd').innerText = ["缓慢", "正常", "快速", "狂暴", "封顶"][val - 1];
        };
    }

    function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }

    function switchView(name) {
        document.getElementById('view-main').style.display = name === 'main' ? 'flex' : 'none';
        document.getElementById('view-settings').style.display = name === 'settings' ? 'flex' : 'none';
    }

    function applySettings() {
        startGame();
    }

    function startGame() {
        if (!game.audio) initAudio();
        game.segments = [];
        game.cars = [];
        game.particles = [];
        game.player = { x: 0, z: 0, speed: 0, score: 0, rage: 0, kills: 0 };
        game.state = STATE.PLAY;
        generateTrack();
        document.getElementById('menu-layer').style.display = 'none';
        document.getElementById('hud').style.display = 'block';
        document.getElementById('game-container').classList.remove('rush-active');
        showMsg("引擎点火", "RACE START", 2000);
        gameLoop(0);
    }

    function generateTrack() {
        const totalSegs = 3000;
        const roadEdgeNorm = (CONFIG.roadW / CONFIG.laneW);
        let buildAccumulator = 0;
        let nextLandmark = 60 + Math.random() * 30;

        for (let i = 0; i < totalSegs; i++) {
            const curve = (Math.floor(i/100)%2) ? Math.sin(i/20) * 4 : 0;
            const y = Math.sin(i/40) * 1000;
            const buildings = [];
            const progress = i / totalSegs;

            buildAccumulator += SETTINGS.buildDensity;
            const reachLandmark = i >= nextLandmark;

            if (buildAccumulator > 1.0 + Math.random() || reachLandmark) {
                buildAccumulator = 0;
                if (reachLandmark) nextLandmark = i + 60 + Math.random() * 35;
                const isLandmark = reachLandmark;
                buildings.push(createBuilding(-1, roadEdgeNorm, isLandmark, progress));
                buildings.push(createBuilding(1, roadEdgeNorm, isLandmark, progress));
            }

            const sprites = [];
            if (i > 50 && Math.random() < 0.03) {
                const safeZone = roadEdgeNorm * 0.8;
                sprites.push({ type: 'block', x: (Math.random()*2 - 1) * safeZone });
            }

            if (i > 50 && Math.random() < SETTINGS.carDensity) {
                let speed = (3000 + Math.random()*2000) * SETTINGS.carSpeedMult;
                const safeZone = roadEdgeNorm * 0.8;
                game.cars.push({ z: i * CONFIG.segL, x: (Math.random()*2-1)*safeZone, speed: speed, active: true });
            }

            game.segments.push({
                index: i,
                p1: { world: { y: y, z: i*CONFIG.segL }, camera: {}, screen: {} },
                p2: { world: { y: y, z: (i+1)*CONFIG.segL }, camera: {}, screen: {} },
                curve: curve,
                sprites: sprites,
                buildings: buildings,
                color: Math.floor(i/5)%2 ? CONFIG.colors.roadDark : CONFIG.colors.roadLight
            });
        }
    }

    function randRange(a,b){ return a + Math.random()*(b-a); }

    function createBuilding(side, roadEdgeNorm, isLandmark, progress){
        const width = isLandmark ? randRange(4.2,5.5) : randRange(1.2,3.5);
        const heightBase = isLandmark ? randRange(12000,18000) : randRange(4000,12000);
        const speedBoost = 1 + progress * 0.6;
        const height = heightBase * speedBoost;
        const buffer = 0.2 + Math.random()*0.25;
        const x = side * (roadEdgeNorm + buffer + width/2);
        const type = isLandmark ? ['mega','tower','gate'][Math.floor(Math.random()*3)] : 'normal';
        const tilt = (isLandmark ? 0.015 : 0.008) * (Math.random()>0.5?1:-1);
        return { x, w: width, h: height, c: Math.random(), type, tilt, seed: Math.random() };
    }

    let lastTime = 0;
    function gameLoop(time) {
        if (game.state === STATE.MENU) return;
        const dt = Math.min(0.1, (time - lastTime) / 1000);
        lastTime = time;
        update(dt);
        render();
        requestAnimationFrame(gameLoop);
    }

    function update(dt) {
        const p = game.player;
        const maxS = (game.state === STATE.RUSH) ? CONFIG.rushSpeed : CONFIG.maxSpeed;

        p.speed += CONFIG.accel * (game.state === STATE.RUSH ? 10 : 1);
        if (p.speed > maxS) p.speed = maxS;
        p.z += p.speed * dt;

        let speedRatio = (p.speed / CONFIG.maxSpeed);
        let dx = dt * (2.0 * speedRatio + 0.5);
        if (game.state === STATE.RUSH) dx *= 1.5;

        if (game.keys.left) p.x -= dx;
        if (game.keys.right) p.x += dx;

        const currentSeg = game.segments[Math.floor(p.z/CONFIG.segL) % game.segments.length];
        p.x -= (dx * speedRatio * currentSeg.curve * 0.8);

        const currentRoadLimit = (CONFIG.roadW / CONFIG.laneW) * SETTINGS.roadWidthScale - 0.1;
        if (p.x < -currentRoadLimit) { p.x = -currentRoadLimit; if(p.speed>8000) p.speed-=100; }
        if (p.x > currentRoadLimit) { p.x = currentRoadLimit; if(p.speed>8000) p.speed-=100; }

        game.cars.forEach(car => {
            car.z += car.speed * dt;
            if (Math.abs(car.z - p.z) < 300 && Math.abs(car.x - p.x) < 0.7) handleCollision(car, 'car', currentSeg);
        });
        currentSeg.sprites.forEach((s, i) => {
            if (Math.abs(p.x - s.x) < 0.7) { handleCollision(s, 'obs', currentSeg); currentSeg.sprites.splice(i, 1); }
        });
        // 清理失效车辆
        game.cars = game.cars.filter(c => c.active !== false);

        if (game.state === STATE.RUSH) {
            p.rage -= dt * 20;
            p.score += 2000 * dt;
            if (p.rage <= 0) exitRushMode();
        } else {
            p.rage = Math.max(0, p.rage - dt * CONFIG.rageDrain);
            if (p.rage >= 100) enterRushMode();
        }

        if (game.cam.shake > 0) game.cam.shake = Math.max(0, game.cam.shake - dt*100);

        // 速度分档用于界面速度特效
        speedTier = getSpeedTier(p.speed);

        updateUI();
        updateParticles(dt);
    }

    function getSpeedTier(v){
        if (v > 10000) return 3;
        if (v > 7000) return 2;
        if (v > 4000) return 1;
        return 0;
    }

    function handleCollision(target, type, segRef) {
        const p = game.player;
        const isRush = game.state === STATE.RUSH;
        game.cam.shake = isRush ? 15 : 30;
        const hitPos = screenPosFromTarget(target, segRef);
        spawnExplosion(hitPos.x, hitPos.y, 40, isRush ? '#0ff' : '#f90');
        spawnSmoke(hitPos.x, hitPos.y, 30);
        playExplosionSound(isRush ? 0.8 : 1.2);

        if (isRush) {
            if (type === 'car') { target.active = false; target.z = -5000; }
            p.score += 5000; p.kills++; showMsg("DESTROYED", "+5000");
        } else {
            p.speed *= 0.6;
            game.player.rage += CONFIG.ragePerHit;
            showMsg("IMPACT", "SPEED LOST");
            if (type === 'car') { target.active = false; target.z = -5000; }
        }
    }

    function enterRushMode() {
        game.state = STATE.RUSH;
        document.getElementById('game-container').classList.add('rush-active');
        document.getElementById('rage-container').classList.add('full');
        showMsg("HYPER DRIVE", "ENGAGED");
    }
    function exitRushMode() {
        game.state = STATE.PLAY;
        game.player.rage = 0;
        document.getElementById('game-container').classList.remove('rush-active');
        document.getElementById('rage-container').classList.remove('full');
    }

    function updateParticles(dt) {
        for(let i=game.particles.length-1; i>=0; i--) {
            let pt = game.particles[i];
            pt.x += pt.vx; pt.y += pt.vy; pt.life -= dt; pt.vy += 5*dt;
            if(pt.life <= 0) game.particles.splice(i,1);
        }
    }

    function renderParticles() {
        game.particles.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life;
            ctx.fillRect(p.x, p.y, p.size, p.size);
        });
        ctx.globalAlpha = 1;
    }

    function spawnExplosion(x,y,n,c) {
        for(let i=0;i<n;i++) {
            const a = Math.random()*6.28, s = Math.random()*15+5;
            game.particles.push({x:x,y:y,vx:Math.cos(a)*s,vy:Math.sin(a)*s,life:Math.random(),color:c,size:Math.random()*6+2});
        }
    }

    function spawnSmoke(x,y,n){
        for(let i=0;i<n;i++){
            const a = Math.random()*6.28, s = Math.random()*8;
            game.particles.push({x:x,y:y,vx:Math.cos(a)*s*0.5,vy:Math.sin(a)*s*0.5 - 2,life:0.8+Math.random()*0.6,color:'rgba(80,80,80,0.8)',size:Math.random()*10+6});
        }
    }

    function drawSpeedFX(tier){
        if(tier<=0) return;
        const lines = 25 * tier;
        ctx.save();
        ctx.globalAlpha = 0.12 + tier*0.05;
        ctx.strokeStyle = 'rgba(0,255,255,0.6)';
        ctx.lineWidth = 2 + tier;
        for(let i=0;i<lines;i++){
            const ang = Math.random()*Math.PI*2;
            const len = 80 + Math.random()*120 + tier*40;
            const r = Math.random()*Math.min(W,H)*0.6 + Math.min(W,H)*0.25;
            const x = W/2 + Math.cos(ang)*r;
            const y = H/2 + Math.sin(ang)*r;
            ctx.beginPath();
            ctx.moveTo(x,y);
            ctx.lineTo(x - Math.cos(ang)*len, y - Math.sin(ang)*len);
            ctx.stroke();
        }
        ctx.restore();
    }

    function screenPosFromTarget(target, segRef){
        const laneW = CONFIG.laneW * SETTINGS.roadWidthScale;
        const seg = segRef || game.segments[(Math.floor((target.z||game.player.z)/CONFIG.segL)) % game.segments.length];
        const wz = target.z || (seg ? seg.p1.world.z : game.player.z);
        const wy = seg ? seg.p1.world.y : 0;
        const offsetZ = wz - game.player.z;
        const temp = { world:{ y: wy, z: wz }, camera:{}, screen:{} };
        project(temp, (target.x||0) * laneW, offsetZ);
        return { x: temp.screen.x, y: temp.screen.y };
    }
    function updateUI() {
        document.getElementById('score-val').innerText = Math.floor(game.player.score);
        document.getElementById('speed-val').innerText = Math.floor(game.player.speed/100);
        document.getElementById('kill-val').innerText = game.player.kills;
        document.getElementById('rage-fill').style.width = game.player.rage + '%';
    }
    function showMsg(m,s,t=1000) {
        const el = document.getElementById('center-msg');
        el.innerHTML = `<div class="msg-big">${m}</div><div class="msg-sub">${s}</div>`;
        el.style.display = 'block';
        clearTimeout(game.msgTimer);
        game.msgTimer = setTimeout(()=>el.style.display='none', t);
    }

    function render() {
        ctx.fillStyle = game.state === STATE.RUSH ? '#100' : CONFIG.colors.sky;
        ctx.fillRect(0,0,W,H);

        drawSpeedFX(speedTier);

        let sx = (Math.random()-0.5)*game.cam.shake, sy = (Math.random()-0.5)*game.cam.shake;
        ctx.save(); ctx.translate(sx, sy);

        const baseIdx = Math.floor(game.player.z/CONFIG.segL);
        let maxY = H;

        for(let n=0; n<CONFIG.drawDist; n++) {
            const segment = game.segments[(baseIdx + n) % game.segments.length];
            const loopedIdx = (segment.index < baseIdx) ? segment.index + game.segments.length : segment.index;
            const offsetZ = (loopedIdx * CONFIG.segL) - game.player.z;

            if(offsetZ < CONFIG.camD) continue;

            const currentLaneW = CONFIG.laneW * SETTINGS.roadWidthScale;
            project(segment.p1, game.player.x * currentLaneW, offsetZ);
            project(segment.p2, game.player.x * currentLaneW - (segment.curve * (offsetZ/CONFIG.segL)), offsetZ+CONFIG.segL);

            if(segment.p1.screen.y >= maxY) continue;
            renderRoad(segment);
            maxY = segment.p1.screen.y;
        }

        for(let n=CONFIG.drawDist-1; n>0; n--) {
            const segment = game.segments[(baseIdx + n) % game.segments.length];
            const currentLaneW = CONFIG.laneW * SETTINGS.roadWidthScale;
            segment.buildings.forEach(b => renderBuilding3D(segment, b, currentLaneW));

            game.cars.forEach(car => {
                if(car.z >= segment.p1.world.z && car.z < segment.p2.world.z) {
                    const pct = (car.z - segment.p1.world.z) / CONFIG.segL;
                    renderObject(segment, car.x, currentLaneW, pct, 'car', car);
                }
            });
            segment.sprites.forEach(s => renderObject(segment, s.x, currentLaneW, 0, 'block'));
        }

        renderPlayer();
        renderParticles();
        ctx.restore();
    }

    function project(p, cx, cz) {
        p.camera.x = p.world.x || 0;
        p.camera.y = (p.world.y || 0) - CONFIG.camH;
        p.camera.z = cz;
        p.screen.scale = CONFIG.camD / cz;
        p.screen.x = Math.round((W/2) + (p.screen.scale * (-cx) * W/2));
        p.screen.y = Math.round((H*0.45) - (p.screen.scale * p.camera.y * H/2));
        p.screen.w = Math.round(p.screen.scale * CONFIG.roadW * SETTINGS.roadWidthScale * W/2);
    }

    function renderRoad(s) {
        const p1=s.p1.screen, p2=s.p2.screen;
        const col = game.state===STATE.RUSH ? (Math.floor(s.index/2)%2?'#f0f':'#0ff') : s.color;

        ctx.fillStyle = game.state===STATE.RUSH?'#000':(Math.floor(s.index/5)%2?CONFIG.colors.grassDark:CONFIG.colors.grassLight);
        ctx.fillRect(0, p2.y, W, p1.y-p2.y);

        ctx.fillStyle = col;
        ctx.beginPath();
        ctx.moveTo(p1.x-p1.w, p1.y); ctx.lineTo(p1.x+p1.w, p1.y);
        ctx.lineTo(p2.x+p2.w, p2.y); ctx.lineTo(p2.x-p2.w, p2.y);
        ctx.fill();

        ctx.fillStyle = '#fff';
        const mw = p1.w * 0.05;
        ctx.fillRect(p1.x-p1.w-mw, p1.y, mw, p1.y-p2.y);
        ctx.fillRect(p1.x+p1.w, p1.y, mw, p1.y-p2.y);
    }

    function renderBuilding3D(s, b, laneW) {
        const scale = s.p1.screen.scale;
        if (scale < 0.0003) return;

        const screenX = s.p1.screen.x + (scale * b.x * laneW * W / 2);
        const screenY = s.p1.screen.y;

        const buildW = b.w * laneW * scale * W / 2;
        const buildH = b.h * scale * H / 2;

        if (screenX + buildW < -W*0.2 || screenX - buildW > W*1.2) return;
        if (buildH < 2) return;

        const palette = PALETTES[Math.floor((b.c || 0) * PALETTES.length) % PALETTES.length];
        const type = b.type || 'normal';
        const tilt = (b.tilt || 0) * (b.x < 0 ? -1 : 1);
        const seed = b.seed || b.c || 0.5;

        ctx.save();
        ctx.translate(screenX, screenY);
        ctx.rotate(tilt);

        drawBuildingBase(buildW, buildH, palette, type);
        drawBuildingWindows(buildW, buildH, palette, type, seed, scale);
        drawBuildingGlow(buildW, buildH, palette, type);

        ctx.restore();
    }

    function drawBuildingBase(w, h, palette, type){
        const top = -h;
        const grad = ctx.createLinearGradient(0, top, 0, 0);
        grad.addColorStop(0, palette.light);
        grad.addColorStop(0.4, palette.base);
        grad.addColorStop(1, '#000');

        ctx.fillStyle = grad;
        ctx.fillRect(-w/2, top, w, h);

        ctx.fillStyle = palette.light;
        ctx.globalAlpha = 0.6;
        ctx.fillRect(-w/2, top-4, w, 6);
        ctx.globalAlpha = 1;

        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        const sideW = w * 0.18;
        ctx.fillRect(w/2 - sideW, top, sideW, h);

        ctx.strokeStyle = palette.light;
        ctx.lineWidth = 1;
        ctx.globalAlpha = 0.35;
        ctx.strokeRect(-w/2, top, w, h);
        ctx.globalAlpha = 1;
    }

    function drawBuildingWindows(w, h, palette, type, seed, scale){
        if (w < 4 || h < 8) return;
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        const top = -h;
        const baseAlpha = type === 'mega' ? 0.75 : 0.55;
        ctx.globalAlpha = baseAlpha;
        const color = palette.light;

        if (type === 'mega') {
            const rows = 8;
            for(let i=0;i<rows;i++){
                const y0 = top + (h/rows)*i;
                const bandH = h/rows * 0.8;
                ctx.fillStyle = i%2 ? color : '#fff';
                ctx.fillRect(-w/2, y0, w, bandH);
                ctx.globalAlpha = baseAlpha * (0.4 + 0.6*Math.random());
            }
        } else if (type === 'tower') {
            const cols = Math.max(2, Math.floor(w/18));
            for(let c=0;c<cols;c++){
                if ((c+Math.floor(seed*10))%2===0) continue;
                const x = -w/2 + (w/cols)*c + 2;
                ctx.fillStyle = color;
                ctx.globalAlpha = baseAlpha * (0.5 + 0.5*Math.random());
                ctx.fillRect(x, top, w/cols - 4, h);
            }
        } else if (type === 'gate') {
            ctx.strokeStyle = color;
            ctx.lineWidth = 8;
            ctx.globalAlpha = baseAlpha;
            const step = 26;
            for(let y=top-40; y<0; y+=step){
                ctx.beginPath();
                ctx.moveTo(-w/2, y);
                ctx.lineTo(w/2, y+40);
                ctx.stroke();
            }
        } else {
            const rows = Math.max(6, Math.floor(h/60));
            const cols = Math.max(3, Math.floor(w/24));
            const cw = w/cols, ch = h/rows;
            for(let r=0;r<rows;r++){
                for(let c=0;c<cols;c++){
                    if (Math.sin(seed*31 + r*0.7 + c*1.3 + Date.now()*0.001) > 0.1) continue;
                    const rx = -w/2 + c*cw + 3;
                    const ry = top + r*ch + 2;
                    ctx.globalAlpha = baseAlpha * (0.5 + 0.5*Math.random());
                    ctx.fillStyle = color;
                    ctx.fillRect(rx, ry, cw-6, ch*0.4);
                }
            }
        }

        ctx.restore();
    }

    function drawBuildingGlow(w, h, palette, type){
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        const glowAlpha = type === 'mega' ? 0.4 : 0.25;
        ctx.fillStyle = palette.light;
        ctx.globalAlpha = glowAlpha;
        ctx.fillRect(-w/2, -h, w, 12);
        ctx.fillRect(-w/2, -h*0.2, w, 6);
        if(type === 'tower'){
            ctx.beginPath();
            ctx.arc(0, -h, w*0.12, 0, Math.PI*2);
            ctx.fill();
        }
        ctx.restore();
    }

    function renderObject(s, lx, laneW, pct, type, obj) {
        const p1 = s.p1.screen, p2 = s.p2.screen;
        const scale = p1.scale + (p2.scale - p1.scale) * pct;
        const sx = p1.x + (p2.x - p1.x) * pct + (scale * lx * laneW * W / 2);
        const sy = p1.y + (p2.y - p1.y) * pct;

        if (type === 'car') {
            const w = 400 * scale * W/2, h = 300 * scale * H/2;
            ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(sx-w/2, sy, w, w*0.2);
            ctx.fillStyle = '#f00'; ctx.fillRect(sx-w/2, sy-h, w, h);
            ctx.fillStyle = '#500'; ctx.fillRect(sx-w/2, sy-h, w, h*0.2);
            ctx.fillStyle = '#f00'; ctx.shadowBlur=10; ctx.shadowColor='#f00';
            ctx.fillRect(sx-w*0.4, sy-h*0.4, w*0.3, h*0.15);
            ctx.fillRect(sx+w*0.1, sy-h*0.4, w*0.3, h*0.15);
            ctx.shadowBlur=0;
        } else {
            const w = 300 * scale * W/2, h = 300 * scale * H/2;
            ctx.fillStyle = '#888'; ctx.fillRect(sx-w/2, sy-h, w, h);
            ctx.fillStyle = '#ff0';
            ctx.beginPath(); ctx.moveTo(sx-w/2, sy-h); ctx.lineTo(sx+w/2, sy); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(sx, sy-h); ctx.lineTo(sx+w/2, sy-h/2); ctx.stroke();
        }
    }

    function renderPlayer() {
        const x=W/2, y=H-80, w=120, h=60;
        const bounce = Math.sin(Date.now()/50)*2;
        ctx.save(); ctx.translate(x, y+bounce);
        if(game.keys.left) ctx.rotate(-0.05); if(game.keys.right) ctx.rotate(0.05);

        if(game.state === STATE.RUSH) {
            ctx.fillStyle = 'rgba(0,255,255,0.2)';
            ctx.fillRect(-w/2-20, -h, w+40, h);
        }

        ctx.fillStyle = '#000'; ctx.strokeStyle = game.state === STATE.RUSH ? '#fff' : '#0ff'; ctx.lineWidth = 4;
        ctx.beginPath(); ctx.moveTo(-w/2, 0); ctx.lineTo(-w/2+10, -h); ctx.lineTo(w/2-10, -h); ctx.lineTo(w/2, 0);
        ctx.fill(); ctx.stroke();

        const fl = (game.player.speed/CONFIG.maxSpeed)*50 + (game.state===STATE.RUSH?120:0);
        ctx.fillStyle = game.state===STATE.RUSH?'#0ff':(Math.random()>0.5?'#f00':'#ff0');
        ctx.shadowBlur=20; ctx.shadowColor=ctx.fillStyle;
        ctx.beginPath(); ctx.moveTo(-30,0); ctx.lineTo(-20,fl); ctx.lineTo(-10,0);
        ctx.moveTo(10,0); ctx.lineTo(20,fl); ctx.lineTo(30,0); ctx.fill();
        ctx.shadowBlur=0;
        ctx.restore();
    }

    function initAudio() {
        const AC = window.AudioContext || window.webkitAudioContext;
        game.audio = new AC();
        const osc = game.audio.createOscillator();
        const gain = game.audio.createGain();
        osc.type = 'sawtooth'; osc.frequency.value=50; gain.gain.value=0.1;
        osc.connect(gain); gain.connect(game.audio.destination); osc.start();
        setInterval(()=>{
            const freq = 50 + (game.player.speed/CONFIG.maxSpeed)*200;
            osc.frequency.setTargetAtTime(freq, game.audio.currentTime, 0.1);
            gain.gain.value = (game.state===STATE.MENU)?0:0.1;
        }, 100);
    }

    function playExplosionSound(intensity=1){
        try{
            if(!game.audio) return;
            const ctxA = game.audio;
            const buffer = ctxA.createBuffer(1, ctxA.sampleRate*0.25, ctxA.sampleRate);
            const data = buffer.getChannelData(0);
            for(let i=0;i<data.length;i++){
                const t = i/data.length;
                data[i] = (Math.random()*2-1)*Math.pow(1-t,2.4)*intensity;
            }
            const src = ctxA.createBufferSource(); src.buffer=buffer;
            const gain = ctxA.createGain(); gain.gain.value=0.6*intensity;
            const bp = ctxA.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=180+intensity*180;
            src.connect(bp).connect(gain).connect(ctxA.destination);
            src.start();
        }catch(e){}
    }

    init();
</script>

</body>
</html>



