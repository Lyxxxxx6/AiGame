<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>失控赛车</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap'); /* 新增科技字体 */

        body { margin: 0; overflow: hidden; background: #000; color: #fff; font-family: 'Orbitron', sans-serif; user-select: none; }
        #game-container { position: relative; width: 100vw; height: 100vh; overflow: hidden;}
        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }

        /* 通用 UI 层 */
        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }

        /* ==================== 剧情化警告层 (重写) ==================== */
        #warning-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 999; display: flex; flex-direction: column;
            justify-content: center; align-items: center; text-align: center;
            pointer-events: auto;
            font-family: 'Share Tech Mono', monospace; /* 打字机/终端风格 */
        }
        .hazard-box {
            border: 2px solid #f00;
            padding: 40px;
            max-width: 900px;
            background: rgba(20, 0, 0, 0.9);
            box-shadow: 0 0 50px rgba(255, 0, 0, 0.2);
            position: relative;
        }
        .hazard-box::before {
            content: "SYSTEM_ALERT // CODE: RED";
            position: absolute; top: -15px; left: 20px;
            background: #000; color: #f00; padding: 0 10px; font-weight: bold;
        }
        .hazard-title {
            font-size: 48px; color: #f00; font-weight: 900; margin-bottom: 20px;
            text-transform: uppercase; letter-spacing: 5px;
            text-shadow: 2px 2px 0 #fff; animation: glitch 0.3s infinite;
        }
        .hazard-desc {
            font-size: 20px; color: #ccc; line-height: 1.8; margin-bottom: 40px; text-align: left;
        }
        .hazard-highlight { color: #fff; font-weight: bold; text-decoration: underline; text-decoration-color: #f00; }

        .confirm-btn {
            background: #f00; color: #000; font-family: 'Orbitron'; font-weight: 900; font-size: 24px;
            padding: 15px 50px; border: none; cursor: pointer; text-transform: uppercase;
            box-shadow: 0 0 20px #f00; transition: 0.3s; clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
        }
        .confirm-btn:hover { background: #fff; color: #f00; box-shadow: 0 0 40px #f00; transform: scale(1.05); }

        /* ==================== 战术指引 HUD (新增) ==================== */
        #tactical-hud {
            position: absolute;
            top: 25%;
            left: 30px;
            width: 300px;
            padding: 20px;
            background: rgba(0, 20, 40, 0.6);
            border-left: 4px solid #0ff;
            font-family: 'Share Tech Mono', monospace;
            font-size: 14px;
            color: #0ff;
            text-shadow: 0 0 5px #0ff;
            pointer-events: none;
            display: none; /* 默认隐藏，开始游戏后显示 */
            backdrop-filter: blur(2px);
        }
        .tac-header { font-size: 18px; color: #fff; border-bottom: 1px solid #0ff; margin-bottom: 10px; padding-bottom: 5px; font-weight: bold; }
        .tac-row { margin-bottom: 8px; display: flex; justify-content: space-between; }
        .tac-key { color: #fff; background: rgba(0,255,255,0.2); padding: 0 5px; font-weight: bold; }
        .tac-desc { text-align: right; color: #acd; }
        .tac-section { margin-top: 15px; border-top: 1px dashed rgba(0,255,255,0.3); padding-top: 10px; }
        .win-cond { color: #0f0; }
        .lose-cond { color: #f33; }

        /* HUD */
        #hud-top { display: flex; justify-content: space-between; padding: 30px; font-weight: 900; letter-spacing: 2px; text-shadow: 0 0 10px #0ff; }
        .stat-value { font-size: 40px; color: #fff; text-shadow: 2px 2px 0 #f0f; font-family: 'Orbitron'; }
        .stat-label { font-size: 16px; color: #0ff; margin-bottom: 5px; }

        #speed-container { position: absolute; top: 10%; left: 50%; transform: translateX(-50%) skew(-10deg); text-align: center; }
        #speed-val { font-size: 100px; line-height: 80px; font-weight: 900; background: linear-gradient(to bottom, #fff, #888); -webkit-background-clip: text; -webkit-text-fill-color: transparent; filter: drop-shadow(0 0 15px #0ff); transition: transform 0.1s; font-family: 'Orbitron'; }
        #speed-unit { font-size: 24px; color: #0ff; letter-spacing: 2px; }

        #rage-container { position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%); width: 600px; height: 40px; border: 4px solid #fff; transform: skew(-20deg); box-shadow: 0 0 30px #f00; background: rgba(0,0,0,0.5); }
        #rage-fill { width: 0%; height: 100%; background: repeating-linear-gradient(45deg, #f00, #f00 10px, #900 10px, #900 20px); transition: width 0.05s linear; }
        #rage-label { position: absolute; width: 100%; text-align: center; top: -25px; color: #f00; font-weight: bold; text-shadow: 0 0 5px #000; letter-spacing: 2px; }

        /* 冲锋时刻UI */
        #rush-score-container { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); text-align: center; display: none; z-index: 50; }
        .rush-title { font-size: 40px; color: #ff0; text-shadow: 0 0 20px #f00; font-weight: 900; letter-spacing: 5px; animation: pulse 0.1s infinite; }
        .rush-val { font-size: 120px; color: #fff; text-shadow: 5px 5px 0 #f0f; font-weight: 900; font-family: 'Orbitron'; }

        /* 消息提示 */
        #center-msg { position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%); text-align: center; white-space: nowrap; z-index: 10; display: none; text-shadow: 0 0 20px #f00;}
        .msg-big { font-size: 80px; font-weight: 900; color: #fff; -webkit-text-stroke: 3px #000; letter-spacing: 5px; }
        .msg-sub { font-size: 30px; color: #0ff; background: #000; padding: 5px 20px; margin-top: 10px; display: inline-block; }

        /* 结局屏幕 */
        .end-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); backdrop-filter: blur(10px); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 200; pointer-events: auto; }
        .end-title { font-size: 120px; font-weight: 900; margin-bottom: 20px; letter-spacing: 10px; font-family: 'Orbitron'; }
        .win-text { color: #ff0; text-shadow: 0 0 50px #fa0; animation: pulse 1s infinite; }
        .lose-text { color: #f00; text-shadow: 0 0 50px #f00; }

        /* 倒计时 */
        #countdown { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 250px; font-weight: 900; color: #fff; -webkit-text-stroke: 5px #000; display: none; z-index: 100; font-style: italic; font-family: 'Orbitron'; }
        .count-anim { animation: pop 0.9s cubic-bezier(0.1, 0.7, 1.0, 0.1) forwards; }

        @keyframes pop { 0% { transform: translate(-50%, -50%) scale(0.2); opacity: 0; } 50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(1.0); opacity: 0; } }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }
        @keyframes alertFlash { 0% { opacity: 0.5; text-shadow: 0 0 10px #f00; border-color: #f00; } 50% { opacity: 1; text-shadow: 0 0 30px #f00, 0 0 50px #f00; border-color: #fff; } 100% { opacity: 0.5; text-shadow: 0 0 10px #f00; border-color: #f00; } }
        @keyframes glitch { 0% { transform: translate(0) } 20% { transform: translate(-2px, 2px) } 40% { transform: translate(-2px, -2px) } 60% { transform: translate(2px, 2px) } 80% { transform: translate(2px, -2px) } 100% { transform: translate(0) } }

        /* 菜单样式 */
        #menu-layer { background: rgba(0,0,0,0.9); backdrop-filter: blur(5px); display: none; flex-direction: column; justify-content: center; align-items: center; pointer-events: auto; z-index: 150;}
        .glitch-title { font-size: 80px; font-weight: 900; color: #fff; text-shadow: 4px 0 #f00, -4px 0 #0ff; margin-bottom: 20px; font-family: 'Orbitron', sans-serif; letter-spacing: 5px; animation: glitch 2s infinite; }
        .story-text {
            color: #f33;
            font-size: 24px;
            margin-bottom: 40px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-align: center;
            max-width: 800px;
            line-height: 1.5;
            animation: alertFlash 1.5s infinite ease-in-out;
            border: 2px solid #f00;
            padding: 15px;
            background: rgba(50, 0, 0, 0.5);
        }

        .menu-view { display: flex; flex-direction: column; align-items: center; width: 100%; transition: opacity 0.3s; }
        .settings-box { background: rgba(0,20,40,0.9); border: 1px solid #0ff; padding: 30px; margin-bottom: 20px; width: 600px; text-align: left; box-shadow: 0 0 30px rgba(0,255,255,0.1); border-radius: 4px; max-height: 70vh; overflow-y: auto; }
        .setting-item { margin-bottom: 25px; }
        .setting-label { color: #fff; font-size: 18px; display:flex; justify-content:space-between; margin-bottom: 8px; font-weight: 700;}
        input[type=range] { width: 100%; height: 6px; background: #333; outline: none; -webkit-appearance: none; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; background: #0ff; cursor: pointer; border: 2px solid #fff; box-shadow: 0 0 10px #0ff; }
        .switch-wrap { position: relative; display: inline-block; width: 60px; height: 30px; }
        .switch-wrap input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #333; transition: .4s; border: 2px solid #fff; }
        .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 3px; bottom: 3px; background-color: white; transition: .4s; }
        input:checked + .slider { background-color: #0ff; }
        input:checked + .slider:before { transform: translateX(30px); background-color: #000; }

        button { background: #000; border: 2px solid #0ff; color: #0ff; padding: 15px 40px; margin: 10px; font-size: 24px; font-family: 'Orbitron', 'Microsoft YaHei'; cursor: pointer; text-transform: uppercase; transition: 0.2s; position: relative; overflow: hidden; width: 400px; font-weight: bold; }
        button:hover { background: #0ff; color: #000; box-shadow: 0 0 30px #0ff; transform: scale(1.05); }
        button.endless-btn { border-color: #f33; color: #f33; }
        button.endless-btn:hover { background: #f33; color: #000; box-shadow: 0 0 30px #f00; }

        .rush-active #gameCanvas { filter: sepia(100%) hue-rotate(290deg) saturate(300%) contrast(1.2); }
    </style>
</head>
<body onkeydown="tryInitAudio()">

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <!-- 剧情化警告层 (重写) -->
    <div id="warning-layer">
        <div class="hazard-box">
            <div class="hazard-title">⚠ 视觉过载警告 ⚠</div>
            <div class="hazard-desc">
                [系统日志]：检测到神经连接端口包含<span class="hazard-highlight">高频闪烁信号</span>与<span class="hazard-highlight">极端色彩脉冲</span>。<br><br>
                即将进入的是一个不稳定的虚拟现实空间。该环境可能诱发<span class="hazard-highlight">光敏性癫痫 (Photosensitive Epilepsy)</span>发作。<br><br>
                > 若您有相关病史或对强光敏感，请立即<strong>[中止连接]</strong>。<br>
                > 强行接入可能导致意识丧失或身体痉挛。后果自负。
            </div>
            <button class="confirm-btn" onclick="acceptWarning()">> 确认风险并接入系统 <</button>
        </div>
    </div>

    <div id="countdown"></div>

    <!-- 冲锋时刻的积分爽感UI -->
    <div id="rush-score-container">
        <div class="rush-title">RUSH BONUS</div>
        <div id="rush-accum-score" class="rush-val">0</div>
    </div>

    <!-- 战术指引 HUD (新增) -->
    <div id="tactical-hud">
        <div class="tac-header">TACTICAL GUIDE // 战术手册</div>
        <div class="tac-row">
            <span class="tac-key">[WASD] / [↑↓←→]</span>
            <span class="tac-desc">战车操控</span>
        </div>
        <div class="tac-row">
            <span class="tac-key">[SPACE]</span>
            <span class="tac-desc">开火清除障碍</span>
        </div>

        <div class="tac-section">
            <div class="tac-header">SCORING // 计分协议</div>
            <div class="tac-row">
                <span>存活距离</span>
                <span class="tac-desc">+800/s</span>
            </div>
            <div class="tac-row">
                <span>摧毁目标</span>
                <span class="tac-desc">+5000 & 怒气</span>
            </div>
            <div class="tac-row" style="color: #fa0;">
                <span>*提示*</span>
                <span class="tac-desc">积攒怒气开启无敌冲锋</span>
            </div>
        </div>

        <div class="tac-section">
            <div class="tac-header">MISSION PROTOCOL</div>
            <div class="tac-row win-cond">
                <span>[VICTORY]</span>
                <span class="tac-desc">能量耗尽前存活</span>
            </div>
            <div class="tac-row lose-cond">
                <span>[FAILURE]</span>
                <span class="tac-desc">速度归零 / 撞毁</span>
            </div>
        </div>
    </div>

    <!-- HUD -->
    <div id="hud" class="ui-layer" style="display: none;">
        <div id="hud-top">
            <div class="stat-group">
                <div class="stat-label" id="score-label">总积分</div>
                <div id="score-val" class="stat-value">0</div>
            </div>
            <div class="stat-group" style="align-items: flex-end;">
                <div class="stat-label">击杀</div>
                <div id="kill-val" class="stat-value" style="color:#f33">0</div>
            </div>
        </div>
        <div id="speed-container">
            <div id="speed-val">0</div>
            <div id="speed-unit">KM/H</div>
        </div>
        <div id="center-msg"></div>
        <div id="rage-container">
            <div id="rage-label">NITRO CHARGE / 攒满开启超级冲锋</div>
            <div id="rage-fill"></div>
        </div>
    </div>

    <!-- 结算画面 -->
    <div id="end-screen" class="end-screen">
        <div id="end-title" class="end-title"></div>
        <div id="end-msg" style="font-size: 24px; margin-bottom: 30px; color: #aaa;"></div>
        <button onclick="returnToMenu()">返回主菜单</button>
    </div>

    <!-- 菜单 -->
    <div id="menu-layer" class="ui-layer">
        <div class="glitch-title">失控赛车</div>
        <div class="story-text">
            系统提示：未知物体正在高速接近<br>
            开启【超级冲锋】即可逃离此地！
        </div>

        <div id="view-main" class="menu-view">
            <button onclick="startSequence('normal')">启动引擎 (剧情模式)</button>
            <button class="endless-btn" onclick="startSequence('endless')">💀 无尽逃脱 (无尽模式)</button>
            <button onclick="switchView('settings')">系统设置</button>
        </div>

        <div id="view-settings" class="menu-view" style="display: none;">
            <div class="settings-box">
                <h3 style="color: #0ff; border-bottom: 1px solid #444; padding-bottom: 10px; margin-top: 0;">核心参数</h3>
                <div class="setting-item">
                    <label class="setting-label">碰撞盒系数 (Scale) <span id="val-hitbox" style="color:#f0f">0.4</span></label>
                    <input type="range" id="set-hitbox-scale" min="10" max="200" value="40">
                </div>
                <div class="setting-item">
                    <label class="setting-label">调试显示 (Hitboxes)
                        <label class="switch-wrap">
                            <input type="checkbox" id="set-hitbox-debug">
                            <span class="slider"></span>
                        </label>
                    </label>
                </div>

                <h3 style="color: #0ff; border-bottom: 1px solid #444; padding-bottom: 10px; margin-top: 20px;">世界生成</h3>
                <div class="setting-item">
                    <label class="setting-label">车流密度 <span id="val-traf" style="color:#f0f">2%</span></label>
                    <input type="range" id="set-traf" min="0" max="10" value="2">
                </div>
                <div class="setting-item">
                    <label class="setting-label">弯道频率 (Pacing) <span id="val-curve-freq" style="color:#fa0">30%</span></label>
                    <input type="range" id="set-curve-freq" min="10" max="90" value="30">
                </div>
                <div class="setting-item">
                    <label class="setting-label">弯道强度 (Intensity) <span id="val-curve" style="color:#0f0">100%</span></label>
                    <input type="range" id="set-curve" min="50" max="300" value="100">
                </div>
                <div class="setting-item">
                    <label class="setting-label">建筑密度 <span id="val-den" style="color:#0f0">中等</span></label>
                    <input type="range" id="set-den" min="0" max="10" value="5">
                </div>
            </div>
            <button onclick="applySettings()">保存设置</button>
        </div>
    </div>
</div>

<script>
    // --- 美术资产 ---
    const CAR_STYLES = {
        'sedan': { w: 400, h: 220, color: '#333', lights: 'h-bar', speedVar: 1.0 },
        'truck': { w: 500, h: 450, color: '#112', lights: 'v-side', speedVar: 0.8 },
        'racer': { w: 420, h: 180, color: '#222', lights: 'quad', speedVar: 1.4 },
        'tank':  { w: 480, h: 300, color: '#232', lights: 'center', speedVar: 0.9 }
    };
    const OBS_STYLES = {
        'crate':   { w: 300, h: 300, color: '#d60', type: 'box' },
        'barrier': { w: 400, h: 180, color: '#ccc', type: 'trap' },
        'glitch':  { w: 250, h: 400, color: '#f0f', type: 'crystal' }
    };

    // --- 游戏常量 ---
    const CONFIG = {
        segL: 200, laneW: 2400, roadW: 2200, camH: 4500, baseCamD: 0.84, drawDist: 500,
        accel: 120,
        maxSpeed: 18000,    // 180 KM/H
        rushSpeed: 120000,  // 原版恐怖极速
        bulletSpeed: 50000,
        winScore: 999999,
        centrifugal: 0.35, steerSens: 3.5,
        colors: { sky: '#050510', roadDark: '#101015', roadLight: '#181820', grassDark: '#020205', grassLight: '#040408' }
    };

    // --- 设置 ---
    const SETTINGS = {
        hitboxScale: 0.4, showHitboxes: false,
        roadWidthScale: 1.0,
        buildDensity: 0.5,
        carDensity: 0.02,
        curveMult: 1.0,
        curveFreq: 0.3
    };

    const STATE = { WARNING: -1, MENU: 0, COUNTDOWN: 1, PLAY: 2, RUSH: 3, GAMEOVER: 4, VICTORY: 5 };

    let game = {
        state: STATE.WARNING,
        mode: 'normal',
        time: 0, dt: 0,
        segments: [], segmentOffsetIndex: 0,
        cars: [], particles: [], bullets: [], shockwaves: [],
        player: { x: 0, z: 0, speed: 0, score: 0, rage: 0, kills: 0, rushScoreAccumulator: 0 },
        keys: { left: false, right: false, up: false, space: false },
        cam: { shake: 0, y: 0, fovOffset: 0, skyOffset: 0 },
        renderer: { flash: 0 },
        audio: { ctx: null, osc: null, gain: null, noise: null, noiseGain: null, menuLoop: null, isMenuMusicPlaying: false },
        shootCooldown: 0,
        victoryTimer: 0,
        loopId: 0
    };

    let TrackGen = { sectionLeft: 0, type: 'straight', y: 0, targetY: 0, startY: 0, targetCurve: 0, curve: 0 };

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    let W, H;

    function init() {
        resize();
        window.addEventListener('resize', resize);
        window.addEventListener('keydown', e => {
            if(e.key === 'ArrowLeft' || e.key === 'a') game.keys.left = true;
            if(e.key === 'ArrowRight' || e.key === 'd') game.keys.right = true;
            if(e.key === 'ArrowUp' || e.key === 'w') game.keys.up = true;
            if(e.key === ' ') game.keys.space = true;
        });
        window.addEventListener('keyup', e => {
            if(e.key === 'ArrowLeft' || e.key === 'a') game.keys.left = false;
            if(e.key === 'ArrowRight' || e.key === 'd') game.keys.right = false;
            if(e.key === 'ArrowUp' || e.key === 'w') game.keys.up = false;
            if(e.key === ' ') game.keys.space = false;
        });
        bindUI();
        gameLoop(0);
    }

    function acceptWarning() {
        document.getElementById('warning-layer').style.display = 'none';
        document.getElementById('menu-layer').style.display = 'flex';
        game.state = STATE.MENU;
        tryInitAudio();
    }

    function bindUI() {
        document.getElementById('set-hitbox-debug').onchange = function() { SETTINGS.showHitboxes = this.checked; };
        document.getElementById('set-hitbox-scale').oninput = function() { SETTINGS.hitboxScale = this.value / 100; document.getElementById('val-hitbox').innerText = SETTINGS.hitboxScale.toFixed(2); };
        document.getElementById('set-traf').oninput = function() { SETTINGS.carDensity = this.value / 100; document.getElementById('val-traf').innerText = this.value + "%"; };
        document.getElementById('set-den').oninput = function() { SETTINGS.buildDensity = this.value / 10; document.getElementById('val-den').innerText = this.value > 3 ? (this.value>7?"密集":"中等") : "稀疏"; };
        document.getElementById('set-curve').oninput = function() { SETTINGS.curveMult = this.value / 100; document.getElementById('val-curve').innerText = this.value + "%"; };
        document.getElementById('set-curve-freq').oninput = function() { SETTINGS.curveFreq = this.value / 100; document.getElementById('val-curve-freq').innerText = this.value + "%"; };
    }

    function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }

    function switchView(name) {
        document.getElementById('view-main').style.display = name === 'main' ? 'flex' : 'none';
        document.getElementById('view-settings').style.display = name === 'settings' ? 'flex' : 'none';
    }

    function applySettings() { switchView('main'); }

    // --- 音频初始化与管理 ---
    function tryInitAudio() {
        if (!game.audio.ctx) {
            initAudio();
            playMenuMusic();
        } else if (game.audio.ctx.state === 'suspended') {
            game.audio.ctx.resume();
        }
    }

    function stopGameAudio() {
        if (!game.audio.ctx) return;
        if (game.audio.gain) game.audio.gain.gain.setTargetAtTime(0, game.audio.ctx.currentTime, 0.05);
        if (game.audio.noiseGain) game.audio.noiseGain.gain.setTargetAtTime(0, game.audio.ctx.currentTime, 0.05);
    }

    function returnToMenu() {
        document.getElementById('end-screen').style.display = 'none';
        document.getElementById('hud').style.display = 'none';
        document.getElementById('tactical-hud').style.display = 'none'; // 隐藏战术面板
        document.getElementById('countdown').style.display = 'none';
        document.getElementById('rush-score-container').style.display = 'none';
        document.getElementById('game-container').classList.remove('rush-active');
        document.getElementById('menu-layer').style.display = 'flex';
        switchView('main');
        game.state = STATE.MENU;
        game.player.speed = 0;
        stopGameAudio();
        playMenuMusic();
    }

    function startSequence(mode) {
        if (!game.audio.ctx) initAudio();
        stopMenuMusic();
        game.mode = mode;
        game.segments = []; game.segmentOffsetIndex = 0;
        game.cars = []; game.particles = []; game.bullets = []; game.shockwaves = [];
        game.player = { x: 0, z: 0, speed: 0, score: 0, rage: 0, kills: 0, rushScoreAccumulator: 0 };
        game.cam = { shake: 0, y: 0, fovOffset: 0, skyOffset: 0 };
        game.renderer.flash = 0;
        game.victoryTimer = 0;
        game.time = 0;

        TrackGen = { sectionLeft: 0, type: 'straight', y: 0, targetY: 0, startY: 0, targetCurve: 0, curve: 0 };
        extendTrack(CONFIG.drawDist + 200);

        document.getElementById('menu-layer').style.display = 'none';
        document.getElementById('hud').style.display = 'block';
        document.getElementById('tactical-hud').style.display = 'block'; // 显示战术面板
        document.getElementById('rush-score-container').style.display = 'none';
        document.getElementById('score-label').innerText = game.mode === 'endless' ? "无尽分数" : "总积分";

        game.state = STATE.COUNTDOWN;
        runCountdown(3);
    }

    function runCountdown(n) {
        const el = document.getElementById('countdown');
        el.style.display = 'block';
        if (n > 0) {
            el.innerText = n; el.style.color = "#fff"; el.className = 'count-anim';
            playTone(400 + (3-n)*100, 0.1);
            setTimeout(() => runCountdown(n - 1), 1000);
        } else {
            el.innerText = game.mode === 'endless' ? "无尽逃脱!" : "逃离!";
            el.style.color = "#0f0"; el.className = 'count-anim';
            playTone(800, 0.3, 'square');
            game.state = STATE.PLAY; game.player.speed = 3000; game.cam.shake = 20;
            showMsg("全速前进", game.mode === 'endless' ? "没有终点，只有极限" : "积攒怒气开启冲锋!");
            setTimeout(() => { el.style.display = 'none'; }, 1000);
        }
    }

    function extendTrack(count) {
        const roadEdgeNorm = (CONFIG.roadW / CONFIG.laneW);
        let buildAccumulator = 0;
        for (let k = 0; k < count; k++) {
            if (TrackGen.sectionLeft <= 0) {
                const r = Math.random();
                TrackGen.startY = TrackGen.y;
                const remainingBudget = 1.0 - SETTINGS.curveFreq;
                const straightThreshold = remainingBudget * 0.6;
                const curveThreshold = straightThreshold + SETTINGS.curveFreq;

                if (r < straightThreshold) {
                    TrackGen.type = 'straight'; TrackGen.sectionLeft = 20 + Math.random()*20;
                    TrackGen.targetCurve = 0; TrackGen.targetY = TrackGen.y;
                } else if (r < curveThreshold) {
                    TrackGen.type = 'curve'; TrackGen.sectionLeft = 50 + Math.random()*80;
                    TrackGen.targetCurve = (Math.random() > 0.5 ? 1 : -1) * (2 + Math.random() * 4) * SETTINGS.curveMult;
                    TrackGen.targetY = TrackGen.y;
                } else {
                    TrackGen.type = 'hill'; TrackGen.sectionLeft = 40 + Math.random()*60;
                    TrackGen.targetCurve = 0;
                    let dir = (Math.random() > 0.5 ? 1 : -1);
                    if (TrackGen.y > 6000) dir = -1; if (TrackGen.y < -2000) dir = 1;
                    TrackGen.targetY = TrackGen.y + dir * (3000 + Math.random()*4000);
                }
            }
            TrackGen.sectionLeft--;

            if (TrackGen.type === 'hill' && Math.abs(TrackGen.targetY - TrackGen.y) > 10) TrackGen.y += (TrackGen.targetY - TrackGen.startY) / 60;

            const buildings = [];
            buildAccumulator += SETTINGS.buildDensity;
            if (buildAccumulator > 1.0 + Math.random()) {
                buildAccumulator = 0;
                const isLandmark = Math.random() < 0.05;
                buildings.push(createBuilding(-1, roadEdgeNorm, isLandmark));
                buildings.push(createBuilding(1, roadEdgeNorm, isLandmark));
            }

            const i = game.segments.length + game.segmentOffsetIndex;
            const sprites = [];
            if (Math.random() < SETTINGS.buildDensity * 0.03) {
                const keys = Object.keys(OBS_STYLES);
                const styleKey = keys[Math.floor(Math.random() * keys.length)];
                sprites.push({ type: 'obs', style: styleKey, x: (Math.random()*2 - 1) * 0.8, size: 0.8 + Math.random()*0.4, active: true });
            }

            if (Math.random() < SETTINGS.carDensity) {
                const keys = Object.keys(CAR_STYLES);
                const styleKey = keys[Math.floor(Math.random() * keys.length)];
                game.cars.push({
                    z: i * CONFIG.segL,
                    x: (Math.random()*2-1)*0.7,
                    speed: 3000 + Math.random()*4000,
                    active: true,
                    style: styleKey,
                    colorVar: Math.random(),
                    hit: false,
                    vx: 0, vy: 0, flyY: 0, rot: 0
                });
            }

            game.segments.push({
                index: i,
                p1: { world: { y: TrackGen.y, z: i*CONFIG.segL }, camera: {}, screen: {} },
                p2: { world: { y: TrackGen.y, z: (i+1)*CONFIG.segL }, camera: {}, screen: {} },
                curve: TrackGen.targetCurve,
                sprites: sprites, buildings: buildings,
                color: Math.floor(i/5)%2 ? CONFIG.colors.roadDark : CONFIG.colors.roadLight
            });
        }
    }

    function randRange(a,b){ return a + Math.random()*(b-a); }
    function createBuilding(side, roadEdgeNorm, isLandmark){
        const width = isLandmark ? randRange(4.2,5.5) : randRange(1.2,3.5);
        const heightBase = isLandmark ? randRange(15000, 25000) : randRange(4000, 12000);
        return { x: side * (roadEdgeNorm + 0.2 + Math.random()*0.25 + width/2), w: width, h: heightBase, c: Math.random(), type: isLandmark ? ['mega','tower','gate'][Math.floor(Math.random()*3)] : 'normal' };
    }

    let lastTime = 0;
    function gameLoop(time) {
        const dt = Math.min(0.1, (time - lastTime) / 1000);
        lastTime = time;

        if (game.state !== STATE.MENU && game.state !== STATE.WARNING) {
            update(dt);
            render();
        } else if (game.state === STATE.MENU) {
            if(game.segments.length === 0) extendTrack(50);
            game.player.z += 2000 * dt;
            const currentIdx = Math.floor(game.player.z / CONFIG.segL);
            if ((currentIdx - game.segmentOffsetIndex) > 50) {
                extendTrack(50);
                const removeCount = (currentIdx - game.segmentOffsetIndex) - 50;
                game.segments.splice(0, removeCount);
                game.segmentOffsetIndex += removeCount;
            }
            render();
        }
        game.loopId = requestAnimationFrame(gameLoop);
    }

    function findSegment(z) {
        const index = Math.floor(z / CONFIG.segL) - game.segmentOffsetIndex;
        return game.segments[Math.max(0, Math.min(index, game.segments.length - 1))];
    }

    function update(dt) {
        const p = game.player;
        const isRush = game.state === STATE.RUSH;
        const maxS = isRush ? CONFIG.rushSpeed : CONFIG.maxSpeed;
        const accelMult = game.keys.up ? 1.5 : 1.0;

        if (isRush) { p.speed += CONFIG.accel * 5; }
        else { p.speed += CONFIG.accel * accelMult; }

        if (p.speed > maxS) p.speed = maxS;
        if (!game.keys.up && !isRush && p.speed > 0) p.speed -= CONFIG.accel * 0.5;

        p.z += p.speed * dt;

        if (game.state === STATE.PLAY || game.state === STATE.RUSH) {
            p.score += 800 * dt;
        }

        const currentIdx = Math.floor(p.z / CONFIG.segL);
        if ((currentIdx - game.segmentOffsetIndex) > game.segments.length - 300) extendTrack(200);
        if ((currentIdx - game.segmentOffsetIndex) > 200) {
            const removeCount = (currentIdx - game.segmentOffsetIndex) - 200;
            game.segments.splice(0, removeCount);
            game.segmentOffsetIndex += removeCount;
        }

        const currentSeg = findSegment(p.z);
        const pct = (p.z % CONFIG.segL) / CONFIG.segL;
        const trackY = currentSeg.p1.world.y + (currentSeg.p2.world.y - currentSeg.p1.world.y) * pct;

        game.cam.y = trackY + CONFIG.camH;

        let speedRatio = (p.speed / CONFIG.maxSpeed);
        let steerPower = dt * (speedRatio + 0.5) * CONFIG.steerSens;
        if (isRush) steerPower *= 1.5;

        if (game.keys.left) p.x -= steerPower;
        if (game.keys.right) p.x += steerPower;

        p.x -= (currentSeg.curve * speedRatio * CONFIG.centrifugal) * dt;
        game.cam.skyOffset -= (currentSeg.curve * speedRatio * dt * 0.5);

        const currentRoadLimit = (CONFIG.roadW / CONFIG.laneW) * SETTINGS.roadWidthScale - 0.1;
        if (p.x < -currentRoadLimit) { p.x = -currentRoadLimit; if(p.speed>8000) p.speed-=200; }
        if (p.x > currentRoadLimit) { p.x = currentRoadLimit; if(p.speed>8000) p.speed-=200; }

        game.shootCooldown -= dt;
        if (game.keys.space && game.shootCooldown <= 0 && game.state === STATE.PLAY) {
            spawnBullet(p.x, p.z, p.speed);
            game.shootCooldown = 0.2;
            playTone(1200, 0.05, 'sawtooth');
        }

        updateBullets(dt);

        game.cars.forEach(car => {
            if (car.active && car.hit) {
                car.x += car.vx * dt;
                car.flyY += car.vy * dt;
                car.vy -= 80 * dt;
                car.rot += 5 * dt;
                car.z += car.speed * dt;
                car.hitTime += dt;

                if (car.hitTime >= 0.5) {
                    car.active = false;
                    triggerBigExplosion(car.x, car.z, car.flyY, '#fa0');
                }
                if(car.flyY < 0) car.active = false;
            } else if (car.active) {
                car.z += car.speed * dt;
                if (car.z < p.z - 2000) car.z = p.z + CONFIG.drawDist * CONFIG.segL * (0.8 + Math.random()*0.4);
            }
        });

        currentSeg.sprites.forEach((s) => {
            if (s.hit) {
                s.x += s.vx * dt;
                s.flyY += s.vy * dt;
                s.vy -= 80 * dt;
                s.rot += 5 * dt;
            }
        });

        const baseHitWidth = 0.2;
        const dynamicHitWidth = baseHitWidth * SETTINGS.hitboxScale;

        game.cars.forEach(car => {
            if (car.active && !car.hit && Math.abs(car.z - p.z) < (350 * SETTINGS.hitboxScale) && Math.abs(car.x - p.x) < dynamicHitWidth) {
                handlePlayerCollision(car, 'car', currentSeg);
            }
        });

        currentSeg.sprites.forEach((s) => {
            if (s.active && !s.hit && Math.abs(p.x - s.x) < dynamicHitWidth) {
                handlePlayerCollision(s, 'obs', currentSeg);
            }
        });

        // 模式逻辑
        if (isRush) {
            p.rage -= dt * 25;
            const rushBonus = 10000 * dt;
            p.score += rushBonus;
            p.rushScoreAccumulator += rushBonus;
            if (p.rage <= 0) {
                if (game.mode === 'endless') {
                    exitRushMode();
                    showMsg("冷却中...", "重新积攒怒气");
                } else {
                    triggerVictory();
                }
            }
        } else {
            p.rage = Math.max(0, p.rage - dt * 2);
            if (p.rage >= 100) enterRushMode();
            if (p.speed < 2000 && game.time > 3.0) {
                triggerGameOver();
            }
        }

        game.time += dt;
        if (game.cam.shake > 0) game.cam.shake = Math.max(0, game.cam.shake - dt * 100);
        if (game.renderer.flash > 0) game.renderer.flash = Math.max(0, game.renderer.flash - dt * 5);

        const targetFov = CONFIG.baseCamD - (speedRatio * 0.3) - (game.keys.up ? 0.05 : 0);
        game.cam.fovOffset += (targetFov - game.cam.fovOffset) * dt * 2;

        updateAudio(dt);
        updateParticles(dt);
        updateUI();
    }

    function spawnBullet(x, z, playerSpeed) {
        game.bullets.push({ x: x, z: z + 200, speed: CONFIG.bulletSpeed + playerSpeed, life: 1.5, active: true });
    }

    function updateBullets(dt) {
        for (let i = game.bullets.length - 1; i >= 0; i--) {
            let b = game.bullets[i];
            b.z += b.speed * dt;
            b.life -= dt;
            if (b.active) {
                for (let c of game.cars) {
                    if (c.active && !c.hit && Math.abs(c.z - b.z) < 400 && Math.abs(c.x - b.x) < 0.3) {
                        handleBulletHit(b, c, 'car');
                        break;
                    }
                }
                if (b.active) {
                    let seg = findSegment(b.z);
                    if (seg && seg.sprites) {
                        for (let s of seg.sprites) {
                            if (s.active && !s.hit && Math.abs(s.x - b.x) < 0.3) {
                                handleBulletHit(b, s, 'obs');
                                break;
                            }
                        }
                    }
                }
            }
            if (b.life <= 0 || !b.active) game.bullets.splice(i, 1);
        }
    }

    function knockbackObject(target) {
        target.hit = true;
        target.hitTime = 0;
        target.speed = game.player.speed + 1000;
        target.vy = 50 + Math.random() * 20;
        target.vx = (Math.random() > 0.5 ? 1 : -1) * (10 + Math.random() * 20);
        target.flyY = 0;
        target.rot = 0;
    }

    function handleBulletHit(bullet, target, type) {
        bullet.active = false;
        if (type === 'car') {
            target.active = false;
            triggerBigExplosion(target.x, target.z, 0, '#0ff');
            game.player.score += 3000;
            game.player.rage += 5;
            game.player.kills++;
            showMsg("目标摧毁", "+100");
        } else {
            knockbackObject(target);
            const seg = findSegment(bullet.z);
            const hitPos = screenPosFromTarget({x:target.x, z:bullet.z}, seg);
            spawnExplosion(hitPos.x, hitPos.y, 30, '#0ff');
            playExplosionSound(0.5);
            game.player.score += 500;
        }
    }

    function handlePlayerCollision(target, type, segRef) {
        const isRush = game.state === STATE.RUSH;
        game.cam.shake = 50;
        knockbackObject(target);

        const hitPos = screenPosFromTarget(target, segRef);
        spawnExplosion(hitPos.x, hitPos.y, 20, '#fff');
        playCrashSound();

        if (isRush) {
            game.renderer.flash = 0.8;
            game.player.score += 5000;
            game.player.kills++;
        } else {
            if (type === 'car') {
                game.renderer.flash = 0.8;
                game.player.rage += 20;
                game.player.score += 5000;
                game.player.kills++;
                showMsg("野蛮冲撞", "+3000");
                game.player.speed -= 2000;
                if(game.player.speed < 0) game.player.speed = 0;
            } else {
                game.player.speed *= 0.5;
                game.player.speed -= 2000;
                if(game.player.speed < 0) game.player.speed = 0;
                showMsg("严重受损", "速度骤降");
            }
        }
    }

    function triggerBigExplosion(worldX, worldZ, worldY, color) {
        game.renderer.flash = 1.0;
        game.cam.shake = 60;
        playExplosionSound(2.0);
        for(let i=0; i<40; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 100 + Math.random() * 200;
            game.particles.push({
                type: '3d',
                x: worldX, z: worldZ, y: worldY || 0,
                vx: Math.cos(angle) * speed,
                vy: Math.random() * 200,
                vz: Math.sin(angle) * speed,
                color: color,
                size: 200 + Math.random() * 300,
                life: 1.0 + Math.random() * 0.5
            });
        }
        game.shockwaves.push({
            x: worldX, z: worldZ, y: worldY || 0,
            radius: 100,
            maxRadius: 3000,
            life: 1.0,
            color: color
        });
    }

    function triggerGameOver() {
        game.state = STATE.GAMEOVER;
        stopGameAudio();
        const screen = document.getElementById('end-screen');
        const title = document.getElementById('end-title');
        const msg = document.getElementById('end-msg');
        title.innerText = "被捕获";
        title.className = "end-title lose-text";
        msg.innerText = "最终得分: " + Math.floor(game.player.score);
        screen.style.display = 'flex';
        playTone(100, 1.5, 'sawtooth');
    }

    function triggerVictory() {
        game.state = STATE.VICTORY;
        exitRushMode();
        stopGameAudio();
        const screen = document.getElementById('end-screen');
        const title = document.getElementById('end-title');
        const msg = document.getElementById('end-msg');
        title.innerText = "逃出生天";
        title.className = "end-title win-text";
        msg.innerText = "最终得分: " + Math.floor(game.player.score);
        screen.style.display = 'flex';
        playTone(600, 0.2, 'sine'); setTimeout(()=>playTone(800, 0.4, 'sine'), 200);
    }

    function enterRushMode() {
        game.state = STATE.RUSH;
        game.player.rushScoreAccumulator = 0;
        document.getElementById('game-container').classList.add('rush-active');
        document.getElementById('rage-container').classList.add('full');
        document.getElementById('rush-score-container').style.display = 'block';
        showMsg("超级冲锋", "RUSH HOUR!");
    }

    function exitRushMode() {
        if (game.state === STATE.VICTORY) return;
        game.state = STATE.PLAY;
        game.player.rage = 0;
        document.getElementById('game-container').classList.remove('rush-active');
        document.getElementById('rage-container').classList.remove('full');
        document.getElementById('rush-score-container').style.display = 'none';
    }

    function render() {
        ctx.fillStyle = game.state === STATE.RUSH ? '#100' : CONFIG.colors.sky;
        ctx.fillRect(0,0,W,H);

        const bgOffset = (game.cam.skyOffset * W) % W;
        ctx.save(); ctx.fillStyle = '#FFF';
        for(let i=0; i<50; i++) {
            let sx = (Math.sin(i*132.1) * W + bgOffset) % W;
            if(sx < 0) sx += W;
            let sy = (Math.cos(i*45.3) * H/2); if(sy < H/2) ctx.fillRect(sx, sy, 2, 2);
        }
        ctx.restore();

        drawSpeedLines();

        let sx = (Math.random()-0.5)*game.cam.shake;
        let sy = (Math.random()-0.5)*game.cam.shake;
        ctx.save(); ctx.translate(sx, sy);

        const baseIdx = Math.floor(game.player.z/CONFIG.segL) - game.segmentOffsetIndex;
        let maxY = H;
        const currentCamD = game.cam.fovOffset || CONFIG.baseCamD;

        let x = 0; let dx = 0;
        for(let n=0; n<CONFIG.drawDist; n++) {
            const idx = baseIdx + n;
            if(idx >= game.segments.length || idx < 0) continue;

            const segment = game.segments[idx];
            const offsetZ = (segment.index * CONFIG.segL) - game.player.z;
            if(offsetZ < 1) continue;

            dx += segment.curve; x += dx;

            project(segment.p1, (game.player.x * CONFIG.laneW) - x, offsetZ, currentCamD);
            project(segment.p2, (game.player.x * CONFIG.laneW) - x - dx, offsetZ+CONFIG.segL, currentCamD);

            if(segment.p1.screen.y >= maxY) continue;
            renderRoad(segment);
            maxY = segment.p1.screen.y;
        }

        for(let n=CONFIG.drawDist-1; n>0; n--) {
            const idx = baseIdx + n;
            if(idx >= game.segments.length || idx < 0) continue;
            const segment = game.segments[idx];
            const currentLaneW = CONFIG.laneW * SETTINGS.roadWidthScale;

            segment.buildings.forEach(b => renderBuilding3D(segment, b, currentLaneW));

            game.cars.forEach(car => {
                if(car.active) {
                    if ((car.z >= segment.p1.world.z && car.z < segment.p2.world.z) ||
                        (car.hit && Math.abs(car.z - segment.p1.world.z) < CONFIG.segL)) {
                        const seg = findSegment(car.z) || segment;
                        const pct = (car.z - seg.p1.world.z) / CONFIG.segL;
                        renderCarModel(seg, car, currentLaneW, pct);
                    }
                }
            });

            segment.sprites.forEach(s => {
                if(s.active) renderObstacleModel(segment, s, currentLaneW, 0);
            });

            render3DParticles(segment.p1.world.z, segment.p2.world.z, segment, currentLaneW);
        }

        renderBullets(baseIdx);
        if(game.state !== STATE.MENU && game.state !== STATE.WARNING) renderPlayer();
        renderParticles();
        ctx.restore();

        if (game.renderer.flash > 0) {
            ctx.fillStyle = `rgba(255, 255, 255, ${game.renderer.flash})`;
            ctx.fillRect(0, 0, W, H);
        }

        if (game.mode === 'endless' && game.state === STATE.PLAY) {
            ctx.fillStyle = "#fff";
            ctx.font = "20px Orbitron";
            ctx.fillText("ENDLESS LOOP", W - 200, 100);
        }
    }

    function renderBullets(baseIdx) {
        ctx.save(); ctx.strokeStyle = '#0ff'; ctx.lineWidth = 4; ctx.shadowBlur = 10; ctx.shadowColor = '#0ff'; ctx.globalCompositeOperation = 'lighter';
        game.bullets.forEach(b => {
            const bSegIdx = Math.floor(b.z / CONFIG.segL) - game.segmentOffsetIndex;
            if (bSegIdx >= 0 && bSegIdx < game.segments.length) {
                const seg = game.segments[bSegIdx];
                const offsetZ = b.z - game.player.z;
                if(offsetZ > 10) {
                    const hitPos = screenPosFromTarget({x: b.x, z: b.z}, seg);
                    ctx.beginPath(); ctx.moveTo(hitPos.x, hitPos.y); ctx.lineTo(hitPos.x, hitPos.y - 20 * (2000/offsetZ)); ctx.stroke();
                }
            }
        });
        ctx.restore();
    }

    function updateParticles(dt) {
        for(let i=game.particles.length-1; i>=0; i--) {
            let pt = game.particles[i];
            if (pt.type === '3d') {
                pt.x += pt.vx * dt * 0.01;
                pt.y += pt.vy * dt * 10;
                pt.z += pt.vz * dt * 10;
                pt.life -= dt;
                pt.size *= 1.05;
            } else {
                pt.x += pt.vx; pt.y += pt.vy; pt.life -= dt; pt.vy += 5*dt;
            }
            if(pt.life <= 0) game.particles.splice(i,1);
        }
        for(let i=game.shockwaves.length-1; i>=0; i--) {
            let sw = game.shockwaves[i];
            sw.radius += (sw.maxRadius - sw.radius) * dt * 5;
            sw.life -= dt;
            if(sw.life <= 0) game.shockwaves.splice(i, 1);
        }
    }

    function renderParticles() {
        game.particles.forEach(p => {
            if (p.type !== '3d') {
                ctx.fillStyle = p.color; ctx.globalAlpha = p.life;
                ctx.fillRect(p.x, p.y, p.size, p.size);
            }
        });
        ctx.globalAlpha = 1;
    }

    function render3DParticles(zStart, zEnd, seg, laneW) {
        game.particles.forEach(p => {
            if (p.type === '3d' && p.z >= zStart && p.z < zEnd) {
                const screenPos = screenPosFromTarget({x: p.x, z: p.z}, seg);
                const scale = seg.p1.screen.scale;
                const screenY = screenPos.y - (p.y * scale * 2);
                const size = Math.max(0, p.size * scale);
                if (size <= 0) return;

                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(screenPos.x, screenY, size, 0, Math.PI*2);
                ctx.fill();
            }
        });
        ctx.lineWidth = 3;
        game.shockwaves.forEach(sw => {
            if (sw.z >= zStart && sw.z < zEnd) {
                const screenPos = screenPosFromTarget({x: sw.x, z: sw.z}, seg);
                const scale = seg.p1.screen.scale;
                const screenY = screenPos.y - (sw.y * scale * 2);
                const radiusX = Math.abs(sw.radius * scale * laneW * 0.05);
                const radiusY = Math.abs(sw.radius * scale * laneW * 0.02);

                if (radiusX <= 0 || radiusY <= 0) return;

                ctx.globalAlpha = sw.life;
                ctx.strokeStyle = sw.color;
                ctx.beginPath();
                ctx.ellipse(screenPos.x, screenY, radiusX, radiusY, 0, 0, Math.PI*2);
                ctx.stroke();
            }
        });
        ctx.globalAlpha = 1;
    }

    function spawnExplosion(x,y,n,c) {
        for(let i=0;i<n;i++) {
            const a = Math.random()*6.28, s = Math.random()*15+5;
            game.particles.push({x:x,y:y,vx:Math.cos(a)*s,vy:Math.sin(a)*s,life:Math.random(),color:c,size:Math.random()*6+2});
        }
    }

    function drawSpeedLines(){
        const speed = game.player.speed;
        if(speed < 5000 && !game.keys.up) return;
        const intensity = Math.min(1, speed / CONFIG.maxSpeed) + (game.keys.up ? 0.2 : 0);
        const count = Math.floor(20 + intensity * 60);

        ctx.save(); ctx.globalCompositeOperation = 'lighter'; ctx.strokeStyle = `rgba(0, 255, 255, ${0.1 + intensity * 0.4})`; ctx.lineWidth = 2 + intensity * 2;
        const cx = W/2, cy = H/2; ctx.beginPath();
        for(let i=0; i<count; i++) {
            const angle = Math.random() * Math.PI * 2; const dist = 50 + Math.random() * 200; const len = 50 + Math.random() * 400 * (1 + intensity * 2);
            ctx.moveTo(cx + Math.cos(angle) * dist, cy + Math.sin(angle) * dist); ctx.lineTo(cx + Math.cos(angle) * (dist+len), cy + Math.sin(angle) * (dist+len));
        }
        ctx.stroke(); ctx.restore();
    }

    function screenPosFromTarget(target, segRef){
        const laneW = CONFIG.laneW * SETTINGS.roadWidthScale;
        const seg = segRef || findSegment(target.z || game.player.z);
        const wz = target.z || (seg ? seg.p1.world.z : game.player.z);
        const wy = seg ? seg.p1.world.y : 0;
        const offsetZ = wz - game.player.z;
        const currentCamD = game.cam.fovOffset || CONFIG.baseCamD;

        const temp = { world:{ y: wy, z: wz }, camera:{}, screen:{} };
        project(temp, (target.x||0) * laneW, offsetZ, currentCamD);
        return { x: temp.screen.x, y: temp.screen.y };
    }

    function updateUI() {
        document.getElementById('score-val').innerText = Math.floor(game.player.score);
        document.getElementById('rush-accum-score').innerText = "+" + Math.floor(game.player.rushScoreAccumulator);
        document.getElementById('speed-val').innerText = Math.floor(game.player.speed/100);
        document.getElementById('kill-val').innerText = game.player.kills;
        document.getElementById('rage-fill').style.width = game.player.rage + '%';
        if(game.player.speed > 8000) { const r = Math.random()*2-1; document.getElementById('speed-val').style.transform = `skew(-10deg) translate(${r}px, ${r}px)`; }
    }

    function showMsg(m,s,t=1000) { const el = document.getElementById('center-msg'); el.innerHTML = `<div class="msg-big">${m}</div><div class="msg-sub">${s}</div>`; el.style.display = 'block'; clearTimeout(game.msgTimer); game.msgTimer = setTimeout(()=>el.style.display='none', t); }

    function project(p, cx, cz, fov) {
        p.camera.y = (p.world.y || 0) - game.cam.y;
        p.screen.scale = fov / cz;
        p.screen.x = Math.round((W/2) + (p.screen.scale * (-cx) * W/2));
        p.screen.y = Math.round((H*0.5) - (p.screen.scale * p.camera.y * H/2));
        p.screen.w = Math.round(p.screen.scale * CONFIG.roadW * SETTINGS.roadWidthScale * W/2);
    }

    function renderRoad(s) {
        const p1=s.p1.screen, p2=s.p2.screen;
        const col = game.state===STATE.RUSH ? (Math.floor(s.index/2)%2?'#f0f':'#0ff') : s.color;

        ctx.fillStyle = game.state===STATE.RUSH?'#000':(Math.floor(s.index/5)%2?CONFIG.colors.grassDark:CONFIG.colors.grassLight);
        ctx.fillRect(0, p2.y, W, p1.y-p2.y);

        ctx.fillStyle = col; ctx.beginPath(); ctx.moveTo(p1.x-p1.w, p1.y); ctx.lineTo(p1.x+p1.w, p1.y); ctx.lineTo(p2.x+p2.w, p2.y); ctx.lineTo(p2.x-p2.w, p2.y); ctx.fill();
        ctx.fillStyle = '#fff'; const mw = p1.w * 0.05; ctx.fillRect(p1.x-p1.w-mw, p1.y, mw, p1.y-p2.y); ctx.fillRect(p1.x+p1.w, p1.y, mw, p1.y-p2.y);
    }

    function renderBuilding3D(s, b, laneW) {
        const scale = s.p1.screen.scale; const screenX = s.p1.screen.x + (scale * b.x * laneW * W / 2); const screenY = s.p1.screen.y;
        const buildW = b.w * laneW * scale * W / 2; const buildH = b.h * scale * H / 2;
        if (buildW < 2 || buildH < 2 || screenX + buildW < 0 || screenX - buildW > W) return;

        const hue = Math.floor(b.c * 360);
        ctx.save(); ctx.translate(screenX, screenY);
        const grd = ctx.createLinearGradient(0, -buildH, 0, 0); grd.addColorStop(0, `hsla(${hue}, 100%, 70%, 1)`); grd.addColorStop(0.3, `hsla(${hue}, 60%, 20%, 1)`); grd.addColorStop(1, '#000');
        ctx.fillStyle = grd; ctx.fillRect(-buildW/2, -buildH, buildW, buildH);
        ctx.strokeStyle = `hsla(${hue}, 100%, 50%, 0.8)`; ctx.lineWidth = 1; ctx.strokeRect(-buildW/2, -buildH, buildW, buildH);
        if (b.type === 'tower') { ctx.fillStyle = `hsla(${hue},100%,80%,1)`; ctx.fillRect(-2, -buildH-10, 4, 10); }
        ctx.restore();
    }

    function renderCarModel(s, car, laneW, pct) {
        const p1 = s.p1.screen, p2 = s.p2.screen; if (!p1 || !p2 || p1.scale <= 0) return;
        const scale = p1.scale + (p2.scale - p1.scale) * pct; if (scale <= 0) return;
        const sx = p1.x + (p2.x - p1.x) * pct + (scale * car.x * laneW * W / 2); const sy = p1.y + (p2.y - p1.y) * pct;

        const style = CAR_STYLES[car.style] || CAR_STYLES['sedan']; const w = style.w * scale * W / 2; const h = style.h * scale * H / 2;
        if (w < 1 || h < 1) return;

        ctx.save();
        if (car.hit) {
            const flyScale = 1 + (car.flyY || 0) / 1000;
            ctx.translate(sx, sy - (car.flyY || 0) * scale * 5);
            ctx.rotate(car.rot || 0);
            ctx.scale(flyScale, flyScale);
        } else {
            ctx.translate(sx, sy);
        }

        ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(-w/2 - w*0.1, 0, w*1.2, h*0.15);
        const parallax = (sx - W/2) / (W/2); const depth = w * 0.4;
        ctx.fillStyle = '#111';
        if (Math.abs(parallax) > 0.1) { ctx.beginPath(); if (parallax > 0) { ctx.moveTo(-w/2, -h); ctx.lineTo(-w/2, 0); ctx.lineTo(-w/2 - depth*parallax, -h*0.2); ctx.lineTo(-w/2 - depth*parallax, -h*0.8); } else { ctx.moveTo(w/2, -h); ctx.lineTo(w/2, 0); ctx.lineTo(w/2 - depth*parallax, -h*0.2); ctx.lineTo(w/2 - depth*parallax, -h*0.8); } ctx.fill(); }

        const colVar = car.colorVar > 0.5 ? '#444' : style.color; ctx.fillStyle = colVar;
        if (car.style === 'truck') { ctx.fillRect(-w/2, -h, w, h); ctx.fillStyle = '#000'; ctx.fillRect(-w/2+5, -h+10, w-10, h/2); } else if (car.style === 'racer') { ctx.beginPath(); ctx.moveTo(-w/2, 0); ctx.lineTo(w/2, 0); ctx.lineTo(w/3, -h); ctx.lineTo(-w/3, -h); ctx.fill(); } else { ctx.fillRect(-w/2, -h*0.6, w, h*0.6); ctx.fillRect(-w/3, -h, w*0.66, h*0.4); }

        ctx.shadowBlur = 10 * scale * 20; ctx.shadowColor = '#f00'; ctx.fillStyle = '#f00';
        if (style.lights === 'v-side') { ctx.fillRect(-w/2 + 2, -h + 10, w*0.1, h*0.8); ctx.fillRect(w/2 - w*0.1 - 2, -h + 10, w*0.1, h*0.8); } else if (style.lights === 'quad') { const r = h/6; ctx.beginPath(); ctx.arc(-w/3, -h/3, r, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(w/3, -h/3, r, 0, Math.PI*2); ctx.fill(); } else { ctx.fillRect(-w/2 + 5, -h/2, w-10, h/5); }

        ctx.shadowBlur = 0;
        if (SETTINGS.showHitboxes && !car.hit) { const hitW = w * 1.0 * SETTINGS.hitboxScale; ctx.strokeStyle = '#0f0'; ctx.lineWidth = 2; ctx.strokeRect(-hitW/2, -h*1.2, hitW, h*1.4); ctx.fillStyle = 'rgba(0,255,0,0.3)'; ctx.fillRect(-hitW/2, -h*1.2, hitW, h*1.4); }
        ctx.restore();
    }

    function renderObstacleModel(s, obj, laneW, pct) {
        const p1 = s.p1.screen; const scale = p1.scale; const sx = p1.x + (scale * obj.x * laneW * W / 2); const sy = p1.y;
        const style = OBS_STYLES[obj.style] || OBS_STYLES['crate']; const sizeMult = obj.size || 1; const w = style.w * scale * W / 2 * sizeMult; const h = style.h * scale * H / 2 * sizeMult;
        if (w < 2) return;

        ctx.save();
        if (obj.hit) {
            ctx.translate(sx, sy - (obj.flyY || 0) * scale * 5);
            ctx.rotate(obj.rot || 0);
        } else {
            ctx.translate(sx, sy);
        }

        const parallax = (sx - W/2) / (W/2); const depthX = parallax * w * 0.5; const topY = -h * 0.8;

        if (style.type === 'box') { ctx.fillStyle = style.color; ctx.fillRect(-w/2, -h, w, h); ctx.fillStyle = '#ffaa00'; ctx.beginPath(); ctx.moveTo(-w/2, -h); ctx.lineTo(w/2, -h); ctx.lineTo(w/2 + depthX, -h + topY); ctx.lineTo(-w/2 + depthX, -h + topY); ctx.fill(); ctx.fillStyle = '#aa4400'; ctx.beginPath(); if (parallax > 0) { ctx.moveTo(-w/2, -h); ctx.lineTo(-w/2, 0); ctx.lineTo(-w/2 + depthX, topY); ctx.lineTo(-w/2 + depthX, -h + topY); } else { ctx.moveTo(w/2, -h); ctx.lineTo(w/2, 0); ctx.lineTo(w/2 + depthX, topY); ctx.lineTo(w/2 + depthX, -h + topY); } ctx.fill(); ctx.strokeStyle = '#000'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(-w/2, -h); ctx.lineTo(w/2, 0); ctx.stroke(); ctx.beginPath(); ctx.moveTo(w/2, -h); ctx.lineTo(-w/2, 0); ctx.stroke(); } else if (style.type === 'trap') { ctx.fillStyle = '#888'; ctx.beginPath(); ctx.moveTo(-w/2, 0); ctx.lineTo(w/2, 0); ctx.lineTo(w/3, -h); ctx.lineTo(-w/3, -h); ctx.fill(); ctx.fillStyle = '#555'; ctx.beginPath(); if(parallax > 0) { ctx.moveTo(-w/2, 0); ctx.lineTo(-w/3, -h); ctx.lineTo(-w/3+depthX, -h-20); ctx.lineTo(-w/2+depthX, -20); } else { ctx.moveTo(w/2, 0); ctx.lineTo(w/3, -h); ctx.lineTo(w/3+depthX, -h-20); ctx.lineTo(w/2+depthX, -20); } ctx.fill(); } else { ctx.shadowBlur = 20; ctx.shadowColor = style.color; ctx.fillStyle = style.color; ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(w/2, -h/2); ctx.lineTo(0, -h); ctx.lineTo(-w/2, -h/2); ctx.fill(); ctx.fillStyle = '#fff'; ctx.globalAlpha = 0.5; ctx.beginPath(); ctx.moveTo(0, -h); ctx.lineTo(10, -h/2); ctx.lineTo(0, 0); ctx.fill(); ctx.shadowBlur = 0; ctx.globalAlpha = 1; }

        if (SETTINGS.showHitboxes && !obj.hit) { const hitW = w * 1.0 * SETTINGS.hitboxScale; ctx.strokeStyle = '#0f0'; ctx.lineWidth = 2; ctx.strokeRect(-hitW/2, -h*1.2, hitW, h*1.4); ctx.fillStyle = 'rgba(0,255,0,0.3)'; ctx.fillRect(-hitW/2, -h*1.2, hitW, h*1.4); }
        ctx.restore();
    }

    function renderPlayer() {
        const carW = 240, carH = 110; const bounce = (game.player.speed > 5000) ? Math.random()*2 : 0; const x = W/2, y = H - 60 + bounce;
        ctx.save(); ctx.translate(x, y); let tilt = game.keys.left ? -0.05 : (game.keys.right ? 0.05 : 0); ctx.rotate(tilt);
        ctx.fillStyle = '#111'; ctx.fillRect(-carW/2, -carH, carW, carH); ctx.fillStyle = '#222'; ctx.beginPath(); ctx.moveTo(-carW/2 + 20, -carH); ctx.lineTo(carW/2 - 20, -carH); ctx.lineTo(carW/2 - 40, -carH - 40); ctx.lineTo(-carW/2 + 40, -carH - 40); ctx.fill();
        const lightW = 40, lightH = 20; ctx.shadowBlur = 20; ctx.shadowColor = '#f00'; ctx.fillStyle = '#f00'; ctx.fillRect(-carW/2 + 10, -carH + 20, lightW, lightH); ctx.fillRect(carW/2 - 10 - lightW, -carH + 20, lightW, lightH);
        if(game.keys.up || game.state === STATE.RUSH) { ctx.shadowColor = '#0ff'; ctx.fillStyle = '#0ff'; const h = 20 + Math.random() * 40; ctx.fillRect(-30, -10, 15, h); ctx.fillRect(15, -10, 15, h); }
        if(SETTINGS.showHitboxes) { ctx.shadowBlur = 0; ctx.strokeStyle = '#ff0'; ctx.lineWidth = 2; const hitW = carW * SETTINGS.hitboxScale; ctx.strokeRect(-hitW/2, -carH-40, hitW, carH+40); ctx.strokeStyle = '#fff'; ctx.beginPath(); ctx.moveTo(-10, 0); ctx.lineTo(10, 0); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, -10); ctx.lineTo(0, 10); ctx.stroke(); }
        ctx.restore();
    }

    // --- 音效系统 ---
    function initAudio() {
        const AC = window.AudioContext || window.webkitAudioContext;
        game.audio.ctx = new AC();
        const ctxA = game.audio.ctx;

        game.audio.osc = ctxA.createOscillator();
        game.audio.osc.type = 'sawtooth';
        game.audio.gain = ctxA.createGain();
        game.audio.gain.gain.value = 0;
        game.audio.osc.connect(game.audio.gain).connect(ctxA.destination);
        game.audio.osc.start();

        const bSize = ctxA.sampleRate * 2;
        const b = ctxA.createBuffer(1, bSize, ctxA.sampleRate);
        const d = b.getChannelData(0);
        for(let i=0; i<bSize; i++) d[i] = Math.random() * 2 - 1;

        game.audio.noise = ctxA.createBufferSource();
        game.audio.noise.buffer = b;
        game.audio.noise.loop = true;
        game.audio.noiseGain = ctxA.createGain();
        game.audio.noiseGain.gain.value = 0;
        game.audio.noise.connect(game.audio.noiseGain).connect(ctxA.destination);
        game.audio.noise.start();
    }

    function playMenuMusic() {
        if (!game.audio.ctx || game.audio.isMenuMusicPlaying) return;
        game.audio.isMenuMusicPlaying = true;
        const ctxA = game.audio.ctx;
        let nextNoteTime = ctxA.currentTime;

        function scheduleBeat() {
            if (!game.audio.isMenuMusicPlaying) return;

            const osc = ctxA.createOscillator();
            const gain = ctxA.createGain();
            osc.frequency.value = 60;
            osc.frequency.exponentialRampToValueAtTime(30, nextNoteTime + 0.2);
            gain.gain.setValueAtTime(0.5, nextNoteTime);
            gain.gain.exponentialRampToValueAtTime(0.01, nextNoteTime + 0.4);
            osc.connect(gain).connect(ctxA.destination);
            osc.start(nextNoteTime);
            osc.stop(nextNoteTime + 0.5);

            const osc2 = ctxA.createOscillator();
            const gain2 = ctxA.createGain();
            osc2.type = 'square';
            osc2.frequency.setValueAtTime(800, nextNoteTime + 0.25);
            gain2.gain.setValueAtTime(0.05, nextNoteTime + 0.25);
            gain2.gain.exponentialRampToValueAtTime(0.01, nextNoteTime + 0.3);
            osc2.connect(gain2).connect(ctxA.destination);
            osc2.start(nextNoteTime + 0.25);
            osc2.stop(nextNoteTime + 0.3);

            nextNoteTime += 0.5;
            game.audio.menuLoop = setTimeout(scheduleBeat, 400);
        }
        scheduleBeat();
    }

    function stopMenuMusic() {
        game.audio.isMenuMusicPlaying = false;
        if (game.audio.menuLoop) clearTimeout(game.audio.menuLoop);
    }

    function updateAudio(dt) { if (!game.audio.ctx) return; const r = game.player.speed / CONFIG.maxSpeed; const now = game.audio.ctx.currentTime; const engineFreq = 60 + r * 300 + (game.keys.up ? 50 : 0); game.audio.osc.frequency.setTargetAtTime(engineFreq, now, 0.1); game.audio.gain.gain.setTargetAtTime(0.1 + r * 0.1, now, 0.1); game.audio.noiseGain.gain.setTargetAtTime(r * 0.4, now, 0.1); }

    function playExplosionSound(intensity=1){ try{ if(!game.audio.ctx) return; const ctxA = game.audio.ctx; const buffer = ctxA.createBuffer(1, ctxA.sampleRate*0.5, ctxA.sampleRate); const data = buffer.getChannelData(0); for(let i=0;i<data.length;i++){ const t = i/data.length; data[i] = (Math.random()*2-1)*Math.pow(1-t,2.4)*intensity; } const src = ctxA.createBufferSource(); src.buffer=buffer; const gain = ctxA.createGain(); gain.gain.value=0.8*intensity; const bp = ctxA.createBiquadFilter(); bp.type='lowpass'; bp.frequency.value=200+intensity*300; src.connect(bp).connect(gain).connect(ctxA.destination); src.start(); }catch(e){} }

    function playTone(freq, dur, type='sine') { if(!game.audio.ctx) return; const o = game.audio.ctx.createOscillator(); o.type = type; o.frequency.value = freq; const g = game.audio.ctx.createGain(); o.connect(g).connect(game.audio.ctx.destination); o.start(); g.gain.exponentialRampToValueAtTime(0.001, game.audio.ctx.currentTime + dur); o.stop(game.audio.ctx.currentTime + dur); }

    function playCrashSound() { if(!game.audio.ctx) return; const ctxA = game.audio.ctx; const osc = ctxA.createOscillator(); const gain = ctxA.createGain(); osc.type = 'square'; osc.frequency.setValueAtTime(100, ctxA.currentTime); osc.frequency.exponentialRampToValueAtTime(10, ctxA.currentTime + 0.3); gain.gain.setValueAtTime(0.5, ctxA.currentTime); gain.gain.exponentialRampToValueAtTime(0.01, ctxA.currentTime + 0.3); osc.connect(gain).connect(ctxA.destination); osc.start(); osc.stop(ctxA.currentTime + 0.3); }

    init();
</script>
</body>
</html>